### JSON parsing and serialization for Jet.
###
### This module provides JSON Value types, parsing, and serialization.

import core::option::{Option, Some, None}
import core::result::{Result, Ok, Err}
import collections::Map
import collections::Vec

### Opaque handle to a JSON value managed by the runtime.
type ValueHandle = *mut u8

### A JSON value.
###
### This is a wrapper around the runtime's JSON value handle.
type Value = {
    handle: ValueHandle
}

### A JSON number (either integer or float).
###
### This is a wrapper around the runtime's JSON value handle for numbers.
type Number = {
    handle: ValueHandle
}

### Error type for JSON parsing.
type ParseError = {
    message: String,
    position: Int
}

### Error type for JSON serialization.
type SerializeError = {
    message: String
}

### Error type for JSON deserialization.
type DeserializeError = {
    message: String
}

### Result type for JSON parsing operations.
type ParseResult = Result[Value, ParseError]

### Result type for JSON serialization operations.
type SerializeResult = Result[String, SerializeError]

### FFI declarations for JSON operations.
### These functions are provided by the runtime (stdlib/src/json.rs).

### Creates a null JSON value.
extern fn jet_json_value_null() -> ValueHandle

### Creates a boolean JSON value.
extern fn jet_json_value_bool(v: Bool) -> ValueHandle

### Creates an integer JSON value.
extern fn jet_json_value_int(v: Int) -> ValueHandle

### Creates a float JSON value.
extern fn jet_json_value_float(v: Float) -> ValueHandle

### Creates a string JSON value.
extern fn jet_json_value_string(s: *const u8, len: usize) -> ValueHandle

### Creates an empty array JSON value.
extern fn jet_json_value_array() -> ValueHandle

### Creates an empty object JSON value.
extern fn jet_json_value_object() -> ValueHandle

### Frees a JSON value.
extern fn jet_json_value_free(handle: ValueHandle)

### Parses a JSON string into a value.
### Returns a pointer to a result structure: (success: bool, value_or_error: *mut u8, position: usize)
extern fn jet_json_from_str(s: *const u8, len: usize) -> *mut u8

### Serializes a JSON value to a string.
### Returns a pointer to a JetString.
extern fn jet_json_to_string(handle: ValueHandle) -> *mut u8

### Serializes a JSON value to a pretty-printed string.
### Returns a pointer to a JetString.
extern fn jet_json_to_string_pretty(handle: ValueHandle) -> *mut u8

### Returns true if the value is null.
extern fn jet_json_is_null(handle: ValueHandle) -> Bool

### Returns true if the value is a boolean.
extern fn jet_json_is_bool(handle: ValueHandle) -> Bool

### Returns true if the value is a number.
extern fn jet_json_is_number(handle: ValueHandle) -> Bool

### Returns true if the value is a string.
extern fn jet_json_is_string(handle: ValueHandle) -> Bool

### Returns true if the value is an array.
extern fn jet_json_is_array(handle: ValueHandle) -> Bool

### Returns true if the value is an object.
extern fn jet_json_is_object(handle: ValueHandle) -> Bool

### Returns the boolean value if this is a boolean.
extern fn jet_json_as_bool(handle: ValueHandle) -> Bool

### Returns the integer value if this is a number.
extern fn jet_json_as_int(handle: ValueHandle) -> Int

### Returns the float value if this is a number.
extern fn jet_json_as_float(handle: ValueHandle) -> Float

### Returns a pointer to the string data if this is a string.
extern fn jet_json_as_string(handle: ValueHandle) -> *const u8

### Returns the length of the string if this is a string.
extern fn jet_json_string_len(handle: ValueHandle) -> usize

### Gets a value by key from an object.
extern fn jet_json_object_get(handle: ValueHandle, key: *const u8, key_len: usize) -> ValueHandle

### Inserts a key-value pair into an object.
extern fn jet_json_object_insert(obj_handle: ValueHandle, key: *const u8, key_len: usize, value_handle: ValueHandle)

### Gets a value by index from an array.
extern fn jet_json_array_get(handle: ValueHandle, index: usize) -> ValueHandle

### Pushes a value onto an array.
extern fn jet_json_array_push(arr_handle: ValueHandle, value_handle: ValueHandle)

### Returns the length of an array.
extern fn jet_json_array_len(handle: ValueHandle) -> usize

### Returns the number of keys in an object.
extern fn jet_json_object_len(handle: ValueHandle) -> usize

### Converts a JetString pointer to a String.
extern fn jet_string_to_jet_string(ptr: *mut u8) -> String

### Frees a JetString.
extern fn jet_string_free(ptr: *mut u8)

impl ParseError:
    fn message(self) -> String:
        self.message

    fn position(self) -> Int:
        self.position

impl SerializeError:
    fn message(self) -> String:
        self.message

impl DeserializeError:
    fn message(self) -> String:
        self.message

impl Value:
    ### Creates a null JSON value.
    fn null() -> Value:
        unsafe {
            Value { handle: jet_json_value_null() }
        }

    ### Creates a boolean JSON value.
    fn bool(v: Bool) -> Value:
        unsafe {
            Value { handle: jet_json_value_bool(v) }
        }

    ### Creates a number JSON value from an integer.
    fn int(v: Int) -> Value:
        unsafe {
            Value { handle: jet_json_value_int(v) }
        }

    ### Creates a number JSON value from a float.
    fn float(v: Float) -> Value:
        unsafe {
            Value { handle: jet_json_value_float(v) }
        }

    ### Creates a string JSON value.
    fn string(s: String) -> Value:
        unsafe {
            let bytes = s.as_bytes()
            Value { handle: jet_json_value_string(bytes.ptr, bytes.len()) }
        }

    ### Creates an array JSON value.
    fn array() -> Value:
        unsafe {
            Value { handle: jet_json_value_array() }
        }

    ### Creates an object JSON value.
    fn object() -> Value:
        unsafe {
            Value { handle: jet_json_value_object() }
        }

    ### Creates an array JSON value from a vector.
    fn from_vec(vec: Vec[Value]) -> Value:
        let arr = Value.array()
        for v in vec:
            arr.push(v)
        arr

    ### Creates an object JSON value from a map.
    fn from_map(map: Map[String, Value]) -> Value:
        let obj = Value.object()
        for key, value in map:
            obj.insert(key, value)
        obj

    ### Returns true if this value is null.
    fn is_null(self) -> Bool:
        unsafe {
            jet_json_is_null(self.handle)
        }

    ### Returns true if this value is a boolean.
    fn is_bool(self) -> Bool:
        unsafe {
            jet_json_is_bool(self.handle)
        }

    ### Returns true if this value is a number.
    fn is_number(self) -> Bool:
        unsafe {
            jet_json_is_number(self.handle)
        }

    ### Returns true if this value is a string.
    fn is_string(self) -> Bool:
        unsafe {
            jet_json_is_string(self.handle)
        }

    ### Returns true if this value is an array.
    fn is_array(self) -> Bool:
        unsafe {
            jet_json_is_array(self.handle)
        }

    ### Returns true if this value is an object.
    fn is_object(self) -> Bool:
        unsafe {
            jet_json_is_object(self.handle)
        }

    ### Gets a value by key from an object.
    fn get(self, key: String) -> Option[Value]:
        if not self.is_object():
            return None
        unsafe {
            let key_bytes = key.as_bytes()
            let result_handle = jet_json_object_get(self.handle, key_bytes.ptr, key_bytes.len())
            if result_handle.is_null():
                None
            else:
                Some(Value { handle: result_handle })
        }

    ### Gets a value by index from an array.
    fn get_index(self, index: Int) -> Option[Value]:
        if not self.is_array():
            return None
        unsafe {
            let result_handle = jet_json_array_get(self.handle, index as usize)
            if result_handle.is_null():
                None
            else:
                Some(Value { handle: result_handle })
        }

    ### Inserts a key-value pair into an object.
    fn insert(self, key: String, value: Value):
        if not self.is_object():
            return
        unsafe {
            let key_bytes = key.as_bytes()
            jet_json_object_insert(self.handle, key_bytes.ptr, key_bytes.len(), value.handle)
        }

    ### Pushes a value onto an array.
    fn push(self, value: Value):
        if not self.is_array():
            return
        unsafe {
            jet_json_array_push(self.handle, value.handle)
        }

    ### Returns the length of an array or the number of keys in an object.
    fn len(self) -> Int:
        unsafe {
            if self.is_array():
                jet_json_array_len(self.handle) as Int
            else if self.is_object():
                jet_json_object_len(self.handle) as Int
            else:
                0
        }

    ### Returns the boolean value if this is a boolean.
    fn as_bool(self) -> Option[Bool]:
        if not self.is_bool():
            None
        else:
            unsafe {
                Some(jet_json_as_bool(self.handle))
            }

    ### Returns the integer value if this is a number.
    fn as_int(self) -> Option[Int]:
        if not self.is_number():
            None
        else:
            unsafe {
                Some(jet_json_as_int(self.handle))
            }

    ### Returns the float value if this is a number.
    fn as_float(self) -> Option[Float]:
        if not self.is_number():
            None
        else:
            unsafe {
                Some(jet_json_as_float(self.handle))
            }

    ### Returns the string value if this is a string.
    fn as_string(self) -> Option[String]:
        if not self.is_string():
            None
        else:
            unsafe {
                let ptr = jet_json_as_string(self.handle)
                let len = jet_json_string_len(self.handle)
                Some(String.from_raw_parts(ptr, len))
            }

    ### Returns the value as a JSON string.
    fn to_string(self) -> String:
        unsafe {
            let string_ptr = jet_json_to_string(self.handle)
            let result = jet_string_to_jet_string(string_ptr)
            jet_string_free(string_ptr)
            result
        }

    ### Returns the value as a pretty-printed JSON string.
    fn to_string_pretty(self) -> String:
        unsafe {
            let string_ptr = jet_json_to_string_pretty(self.handle)
            let result = jet_string_to_jet_string(string_ptr)
            jet_string_free(string_ptr)
            result
        }

    ### Frees the underlying JSON value.
    ###
    ### Note: This is called automatically when the value goes out of scope
    ### in most cases, but can be called explicitly for early cleanup.
    fn free(self):
        unsafe {
            jet_json_value_free(self.handle)
        }

impl Number:
    ### Creates an integer number.
    fn int(v: Int) -> Number:
        Number { handle: jet_json_value_int(v) }

    ### Creates a float number.
    fn float(v: Float) -> Number:
        Number { handle: jet_json_value_float(v) }

    ### Returns true if this number is an integer.
    fn is_int(self) -> Bool:
        # All numbers created via Number.int() are integers
        # We check if the float representation equals the int representation
        unsafe {
            let int_val = jet_json_as_int(self.handle)
            let float_val = jet_json_as_float(self.handle)
            (float_val as Int) == int_val
        }

    ### Returns true if this number is a float.
    fn is_float(self) -> Bool:
        not self.is_int()

    ### Returns the value as an integer.
    fn as_int(self) -> Int:
        unsafe {
            jet_json_as_int(self.handle)
        }

    ### Returns the value as a float.
    fn as_float(self) -> Float:
        unsafe {
            jet_json_as_float(self.handle)
        }

### Parses a JSON string into a Value.
fn from_str(s: String) -> Result[Value, ParseError]:
    unsafe {
        let bytes = s.as_bytes()
        let result_ptr = jet_json_from_str(bytes.ptr, bytes.len())

        # The result structure is: (success: bool, value_or_error: *mut u8, position: usize)
        let success = *(result_ptr as *const Bool)
        let value_or_error = *((result_ptr + 8) as *const *mut u8)
        let position = *((result_ptr + 16) as *const usize)

        if success:
            Ok(Value { handle: value_or_error })
        else:
            # value_or_error is a pointer to an error message
            let msg_len = *((result_ptr + 24) as *const usize)
            let msg = String.from_raw_parts(value_or_error as *const u8, msg_len)
            Err(ParseError { message: msg, position: position as Int })
    }

### Parses a JSON byte slice into a Value.
fn from_slice(v: Vec[Byte]) -> Result[Value, ParseError]:
    from_str(String.from_utf8(v)?)

### Serializes a Value to a JSON string.
fn to_string(value: Value) -> String:
    value.to_string()

### Serializes a Value to a pretty-printed JSON string.
fn to_string_pretty(value: Value) -> String:
    value.to_string_pretty()

### Serializes a Value to a JSON byte vector.
fn to_vec(value: Value) -> Vec[Byte]:
    value.to_string().into_bytes()

### Serialize trait for types that can be serialized to JSON.
trait Serialize:
    fn serialize(self) -> Value

### Deserialize trait for types that can be deserialized from JSON.
trait Deserialize:
    fn deserialize(value: Value) -> Result[Self, DeserializeError]

### Macro for deriving Serialize
derive Serialize!

### Macro for deriving Deserialize
derive Deserialize!

### Helper functions for common JSON operations

### Creates a JSON array from the given values.
fn array(values: &[Value]) -> Value:
    let arr = Value.array()
    for v in values:
        arr.push(v)
    arr

### Creates a JSON object from the given key-value pairs.
fn object(entries: &[(String, Value)]) -> Value:
    let obj = Value.object()
    for key, value in entries:
        obj.insert(key, value)
    obj

### Parses a JSON string and returns the value, panicking on error.
fn parse(s: String) -> Value:
    match from_str(s):
        Ok(v) -> v
        Err(e) -> panic(f"JSON parse error at position {e.position}: {e.message}")
