### Matrix types for Jet.
###
### This module provides 2x2, 3x3, and 4x4 matrix types for graphics and math.

import basic::{sqrt, sin, cos, tan}
import vector::{Vec2, Vec3, Vec4}

### A 2x2 matrix.
###
### Stored in column-major order for OpenGL compatibility.
type Mat2 = {
    m00: float64, m01: float64
    m10: float64, m11: float64
}

### A 3x3 matrix.
###
### Stored in column-major order for OpenGL compatibility.
type Mat3 = {
    m00: float64, m01: float64, m02: float64
    m10: float64, m11: float64, m12: float64
    m20: float64, m21: float64, m22: float64
}

### A 4x4 matrix.
###
### Stored in column-major order for OpenGL compatibility.
type Mat4 = {
    m00: float64, m01: float64, m02: float64, m03: float64
    m10: float64, m11: float64, m12: float64, m13: float64
    m20: float64, m21: float64, m22: float64, m23: float64
    m30: float64, m31: float64, m32: float64, m33: float64
}

impl Mat2:
    ### Creates a new Mat2 from components (row-major arguments, stored column-major).
    fn new(m00: float64, m01: float64,
           m10: float64, m11: float64) -> Mat2:
        Mat2 { m00: m00, m01: m01, m10: m10, m11: m11 }

    ### Creates an identity matrix.
    fn identity() -> Mat2:
        Mat2 {
            m00: 1.0, m01: 0.0,
            m10: 0.0, m11: 1.0
        }

    ### Creates a zero matrix.
    fn zero() -> Mat2:
        Mat2 {
            m00: 0.0, m01: 0.0,
            m10: 0.0, m11: 0.0
        }

    ### Creates a scaling matrix.
    fn scale(sx: float64, sy: float64) -> Mat2:
        Mat2 {
            m00: sx,  m01: 0.0,
            m10: 0.0, m11: sy
        }

    ### Creates a uniform scaling matrix.
    fn scale_uniform(s: float64) -> Mat2:
        Mat2.scale(s, s)

    ### Creates a rotation matrix (angle in radians).
    fn rotate(angle: float64) -> Mat2:
        let c = cos(angle)
        let s = sin(angle)
        Mat2 {
            m00: c,   m01: -s,
            m10: s,   m11: c
        }

    ### Returns the determinant of the matrix.
    fn determinant(self) -> float64:
        self.m00 * self.m11 - self.m01 * self.m10

    ### Returns the transpose of the matrix.
    fn transpose(self) -> Mat2:
        Mat2 {
            m00: self.m00, m01: self.m10,
            m10: self.m01, m11: self.m11
        }

    ### Returns the inverse of the matrix.
    fn inverse(self) -> Option[Mat2]:
        let det = self.determinant()
        if det == 0.0:
            return None
        let inv_det = 1.0 / det
        Some(Mat2 {
            m00: self.m11 * inv_det,  m01: -self.m01 * inv_det,
            m10: -self.m10 * inv_det, m11: self.m00 * inv_det
        })

    ### Multiplies the matrix by a vector.
    fn mul_vec(self, v: Vec2) -> Vec2:
        Vec2 {
            x: self.m00 * v.x + self.m01 * v.y,
            y: self.m10 * v.x + self.m11 * v.y
        }

    ### Multiplies two matrices.
    fn mul_mat(self, other: Mat2) -> Mat2:
        Mat2 {
            m00: self.m00 * other.m00 + self.m01 * other.m10,
            m01: self.m00 * other.m01 + self.m01 * other.m11,
            m10: self.m10 * other.m00 + self.m11 * other.m10,
            m11: self.m10 * other.m01 + self.m11 * other.m11
        }

    ### Returns the trace of the matrix (sum of diagonal).
    fn trace(self) -> float64:
        self.m00 + self.m11

impl Mul[Vec2] for Mat2:
    type Output = Vec2
    fn mul(self, v: Vec2) -> Vec2:
        self.mul_vec(v)

impl Mul[Mat2] for Mat2:
    type Output = Mat2
    fn mul(self, other: Mat2) -> Mat2:
        self.mul_mat(other)

impl Eq for Mat2:
    fn eq(self, other: Mat2) -> bool:
        self.m00 == other.m00 and self.m01 == other.m01 and
        self.m10 == other.m10 and self.m11 == other.m11

impl Mat3:
    ### Creates a new Mat3 from components.
    fn new(m00: float64, m01: float64, m02: float64,
           m10: float64, m11: float64, m12: float64,
           m20: float64, m21: float64, m22: float64) -> Mat3:
        Mat3 {
            m00: m00, m01: m01, m02: m02,
            m10: m10, m11: m11, m12: m12,
            m20: m20, m21: m21, m22: m22
        }

    ### Creates an identity matrix.
    fn identity() -> Mat3:
        Mat3 {
            m00: 1.0, m01: 0.0, m02: 0.0,
            m10: 0.0, m11: 1.0, m12: 0.0,
            m20: 0.0, m21: 0.0, m22: 1.0
        }

    ### Creates a zero matrix.
    fn zero() -> Mat3:
        Mat3 {
            m00: 0.0, m01: 0.0, m02: 0.0,
            m10: 0.0, m11: 0.0, m12: 0.0,
            m20: 0.0, m21: 0.0, m22: 0.0
        }

    ### Creates a scaling matrix.
    fn scale(sx: float64, sy: float64) -> Mat3:
        Mat3 {
            m00: sx,  m01: 0.0, m02: 0.0,
            m10: 0.0, m11: sy,  m12: 0.0,
            m20: 0.0, m21: 0.0, m22: 1.0
        }

    ### Creates a uniform scaling matrix.
    fn scale_uniform(s: float64) -> Mat3:
        Mat3.scale(s, s)

    ### Creates a translation matrix (for 2D homogeneous coordinates).
    fn translate(tx: float64, ty: float64) -> Mat3:
        Mat3 {
            m00: 1.0, m01: 0.0, m02: tx,
            m10: 0.0, m11: 1.0, m12: ty,
            m20: 0.0, m21: 0.0, m22: 1.0
        }

    ### Creates a 2D rotation matrix (angle in radians).
    fn rotate_z(angle: float64) -> Mat3:
        let c = cos(angle)
        let s = sin(angle)
        Mat3 {
            m00: c,   m01: -s,  m02: 0.0,
            m10: s,   m11: c,   m12: 0.0,
            m20: 0.0, m21: 0.0, m22: 1.0
        }

    ### Returns the determinant of the matrix.
    fn determinant(self) -> float64:
        self.m00 * (self.m11 * self.m22 - self.m12 * self.m21) -
        self.m01 * (self.m10 * self.m22 - self.m12 * self.m20) +
        self.m02 * (self.m10 * self.m21 - self.m11 * self.m20)

    ### Returns the transpose of the matrix.
    fn transpose(self) -> Mat3:
        Mat3 {
            m00: self.m00, m01: self.m10, m02: self.m20,
            m10: self.m01, m11: self.m11, m12: self.m21,
            m20: self.m02, m21: self.m12, m22: self.m22
        }

    ### Multiplies the matrix by a vector.
    fn mul_vec(self, v: Vec3) -> Vec3:
        Vec3 {
            x: self.m00 * v.x + self.m01 * v.y + self.m02 * v.z,
            y: self.m10 * v.x + self.m11 * v.y + self.m12 * v.z,
            z: self.m20 * v.x + self.m21 * v.y + self.m22 * v.z
        }

    ### Multiplies two matrices.
    fn mul_mat(self, other: Mat3) -> Mat3:
        Mat3 {
            m00: self.m00 * other.m00 + self.m01 * other.m10 + self.m02 * other.m20,
            m01: self.m00 * other.m01 + self.m01 * other.m11 + self.m02 * other.m21,
            m02: self.m00 * other.m02 + self.m01 * other.m12 + self.m02 * other.m22,
            m10: self.m10 * other.m00 + self.m11 * other.m10 + self.m12 * other.m20,
            m11: self.m10 * other.m01 + self.m11 * other.m11 + self.m12 * other.m21,
            m12: self.m10 * other.m02 + self.m11 * other.m12 + self.m12 * other.m22,
            m20: self.m20 * other.m00 + self.m21 * other.m10 + self.m22 * other.m20,
            m21: self.m20 * other.m01 + self.m21 * other.m11 + self.m22 * other.m21,
            m22: self.m20 * other.m02 + self.m21 * other.m12 + self.m22 * other.m22
        }

    ### Returns the trace of the matrix.
    fn trace(self) -> float64:
        self.m00 + self.m11 + self.m22

    ### Extracts the upper-left 2x2 matrix.
    fn to_mat2(self) -> Mat2:
        Mat2 {
            m00: self.m00, m01: self.m01,
            m10: self.m10, m11: self.m11
        }

impl Mul[Vec3] for Mat3:
    type Output = Vec3
    fn mul(self, v: Vec3) -> Vec3:
        self.mul_vec(v)

impl Mul[Mat3] for Mat3:
    type Output = Mat3
    fn mul(self, other: Mat3) -> Mat3:
        self.mul_mat(other)

impl Eq for Mat3:
    fn eq(self, other: Mat3) -> bool:
        self.m00 == other.m00 and self.m01 == other.m01 and self.m02 == other.m02 and
        self.m10 == other.m10 and self.m11 == other.m11 and self.m12 == other.m12 and
        self.m20 == other.m20 and self.m21 == other.m21 and self.m22 == other.m22

impl Mat4:
    ### Creates a new Mat4 from components.
    fn new(m00: float64, m01: float64, m02: float64, m03: float64,
           m10: float64, m11: float64, m12: float64, m13: float64,
           m20: float64, m21: float64, m22: float64, m23: float64,
           m30: float64, m31: float64, m32: float64, m33: float64) -> Mat4:
        Mat4 {
            m00: m00, m01: m01, m02: m02, m03: m03,
            m10: m10, m11: m11, m12: m12, m13: m13,
            m20: m20, m21: m21, m22: m22, m23: m23,
            m30: m30, m31: m31, m32: m32, m33: m33
        }

    ### Creates an identity matrix.
    fn identity() -> Mat4:
        Mat4 {
            m00: 1.0, m01: 0.0, m02: 0.0, m03: 0.0,
            m10: 0.0, m11: 1.0, m12: 0.0, m13: 0.0,
            m20: 0.0, m21: 0.0, m22: 1.0, m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a zero matrix.
    fn zero() -> Mat4:
        Mat4 {
            m00: 0.0, m01: 0.0, m02: 0.0, m03: 0.0,
            m10: 0.0, m11: 0.0, m12: 0.0, m13: 0.0,
            m20: 0.0, m21: 0.0, m22: 0.0, m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 0.0
        }

    ### Creates a scaling matrix.
    fn scale(sx: float64, sy: float64, sz: float64) -> Mat4:
        Mat4 {
            m00: sx,  m01: 0.0, m02: 0.0, m03: 0.0,
            m10: 0.0, m11: sy,  m12: 0.0, m13: 0.0,
            m20: 0.0, m21: 0.0, m22: sz,  m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a uniform scaling matrix.
    fn scale_uniform(s: float64) -> Mat4:
        Mat4.scale(s, s, s)

    ### Creates a translation matrix.
    fn translate(tx: float64, ty: float64, tz: float64) -> Mat4:
        Mat4 {
            m00: 1.0, m01: 0.0, m02: 0.0, m03: tx,
            m10: 0.0, m11: 1.0, m12: 0.0, m13: ty,
            m20: 0.0, m21: 0.0, m22: 1.0, m23: tz,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a rotation matrix around the X axis.
    fn rotate_x(angle: float64) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        Mat4 {
            m00: 1.0, m01: 0.0, m02: 0.0, m03: 0.0,
            m10: 0.0, m11: c,   m12: -s,  m13: 0.0,
            m20: 0.0, m21: s,   m22: c,   m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a rotation matrix around the Y axis.
    fn rotate_y(angle: float64) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        Mat4 {
            m00: c,   m01: 0.0, m02: s,   m03: 0.0,
            m10: 0.0, m11: 1.0, m12: 0.0, m13: 0.0,
            m20: -s,  m21: 0.0, m22: c,   m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a rotation matrix around the Z axis.
    fn rotate_z(angle: float64) -> Mat4:
        let c = cos(angle)
        let s = sin(angle)
        Mat4 {
            m00: c,   m01: -s,  m02: 0.0, m03: 0.0,
            m10: s,   m11: c,   m12: 0.0, m13: 0.0,
            m20: 0.0, m21: 0.0, m22: 1.0, m23: 0.0,
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Creates a perspective projection matrix.
    fn perspective(fov: float64, aspect: float64, near: float64, far: float64) -> Mat4:
        let f = 1.0 / tan(fov / 2.0)
        let nf = 1.0 / (near - far)
        Mat4 {
            m00: f / aspect, m01: 0.0, m02: 0.0,           m03: 0.0,
            m10: 0.0,        m11: f,    m12: 0.0,           m13: 0.0,
            m20: 0.0,        m21: 0.0, m22: (far + near) * nf, m23: 2.0 * far * near * nf,
            m30: 0.0,        m31: 0.0, m32: -1.0,          m33: 0.0
        }

    ### Creates an orthographic projection matrix.
    fn ortho(left: float64, right: float64, bottom: float64, top: float64, near: float64, far: float64) -> Mat4:
        let rl = right - left
        let tb = top - bottom
        let fn = far - near
        Mat4 {
            m00: 2.0 / rl, m01: 0.0,      m02: 0.0,       m03: -(right + left) / rl,
            m10: 0.0,      m11: 2.0 / tb, m12: 0.0,       m13: -(top + bottom) / tb,
            m20: 0.0,      m21: 0.0,      m22: -2.0 / fn, m23: -(far + near) / fn,
            m30: 0.0,      m31: 0.0,      m32: 0.0,       m33: 1.0
        }

    ### Creates a look-at view matrix.
    fn look_at(eye: Vec3, target: Vec3, up: Vec3) -> Mat4:
        let z = (eye - target).normalize()
        let x = up.cross(z).normalize()
        let y = z.cross(x)
        Mat4 {
            m00: x.x, m01: x.y, m02: x.z, m03: -x.dot(eye),
            m10: y.x, m11: y.y, m12: y.z, m13: -y.dot(eye),
            m20: z.x, m21: z.y, m22: z.z, m23: -z.dot(eye),
            m30: 0.0, m31: 0.0, m32: 0.0, m33: 1.0
        }

    ### Returns the transpose of the matrix.
    fn transpose(self) -> Mat4:
        Mat4 {
            m00: self.m00, m01: self.m10, m02: self.m20, m03: self.m30,
            m10: self.m01, m11: self.m11, m12: self.m21, m13: self.m31,
            m20: self.m02, m21: self.m12, m22: self.m22, m23: self.m32,
            m30: self.m03, m31: self.m13, m32: self.m23, m33: self.m33
        }

    ### Multiplies the matrix by a vector.
    fn mul_vec(self, v: Vec4) -> Vec4:
        Vec4 {
            x: self.m00 * v.x + self.m01 * v.y + self.m02 * v.z + self.m03 * v.w,
            y: self.m10 * v.x + self.m11 * v.y + self.m12 * v.z + self.m13 * v.w,
            z: self.m20 * v.x + self.m21 * v.y + self.m22 * v.z + self.m23 * v.w,
            w: self.m30 * v.x + self.m31 * v.y + self.m32 * v.z + self.m33 * v.w
        }

    ### Multiplies the matrix by a Vec3 (treating w as 1).
    fn mul_vec3(self, v: Vec3) -> Vec3:
        let v4 = self.mul_vec(Vec4 { x: v.x, y: v.y, z: v.z, w: 1.0 })
        if v4.w == 0.0:
            Vec3 { x: v4.x, y: v4.y, z: v4.z }
        else:
            Vec3 { x: v4.x / v4.w, y: v4.y / v4.w, z: v4.z / v4.w }

    ### Multiplies two matrices.
    fn mul_mat(self, other: Mat4) -> Mat4:
        Mat4 {
            m00: self.m00 * other.m00 + self.m01 * other.m10 + self.m02 * other.m20 + self.m03 * other.m30,
            m01: self.m00 * other.m01 + self.m01 * other.m11 + self.m02 * other.m21 + self.m03 * other.m31,
            m02: self.m00 * other.m02 + self.m01 * other.m12 + self.m02 * other.m22 + self.m03 * other.m32,
            m03: self.m00 * other.m03 + self.m01 * other.m13 + self.m02 * other.m23 + self.m03 * other.m33,
            m10: self.m10 * other.m00 + self.m11 * other.m10 + self.m12 * other.m20 + self.m13 * other.m30,
            m11: self.m10 * other.m01 + self.m11 * other.m11 + self.m12 * other.m21 + self.m13 * other.m31,
            m12: self.m10 * other.m02 + self.m11 * other.m12 + self.m12 * other.m22 + self.m13 * other.m32,
            m13: self.m10 * other.m03 + self.m11 * other.m13 + self.m12 * other.m23 + self.m13 * other.m33,
            m20: self.m20 * other.m00 + self.m21 * other.m10 + self.m22 * other.m20 + self.m23 * other.m30,
            m21: self.m20 * other.m01 + self.m21 * other.m11 + self.m22 * other.m21 + self.m23 * other.m31,
            m22: self.m20 * other.m02 + self.m21 * other.m12 + self.m22 * other.m22 + self.m23 * other.m32,
            m23: self.m20 * other.m03 + self.m21 * other.m13 + self.m22 * other.m23 + self.m23 * other.m33,
            m30: self.m30 * other.m00 + self.m31 * other.m10 + self.m32 * other.m20 + self.m33 * other.m30,
            m31: self.m30 * other.m01 + self.m31 * other.m11 + self.m32 * other.m21 + self.m33 * other.m31,
            m32: self.m30 * other.m02 + self.m31 * other.m12 + self.m32 * other.m22 + self.m33 * other.m32,
            m33: self.m30 * other.m03 + self.m31 * other.m13 + self.m32 * other.m23 + self.m33 * other.m33
        }

    ### Returns the trace of the matrix.
    fn trace(self) -> float64:
        self.m00 + self.m11 + self.m22 + self.m33

    ### Extracts the upper-left 3x3 matrix.
    fn to_mat3(self) -> Mat3:
        Mat3 {
            m00: self.m00, m01: self.m01, m02: self.m02,
            m10: self.m10, m11: self.m11, m12: self.m12,
            m20: self.m20, m21: self.m21, m22: self.m22
        }

impl Mul[Vec4] for Mat4:
    type Output = Vec4
    fn mul(self, v: Vec4) -> Vec4:
        self.mul_vec(v)

impl Mul[Vec3] for Mat4:
    type Output = Vec3
    fn mul(self, v: Vec3) -> Vec3:
        self.mul_vec3(v)

impl Mul[Mat4] for Mat4:
    type Output = Mat4
    fn mul(self, other: Mat4) -> Mat4:
        self.mul_mat(other)

impl Eq for Mat4:
    fn eq(self, other: Mat4) -> bool:
        self.m00 == other.m00 and self.m01 == other.m01 and self.m02 == other.m02 and self.m03 == other.m03 and
        self.m10 == other.m10 and self.m11 == other.m11 and self.m12 == other.m12 and self.m13 == other.m13 and
        self.m20 == other.m20 and self.m21 == other.m21 and self.m22 == other.m22 and self.m23 == other.m23 and
        self.m30 == other.m30 and self.m31 == other.m31 and self.m32 == other.m32 and self.m33 == other.m33
