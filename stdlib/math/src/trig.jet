### Trigonometric functions for Jet.
###
### This module provides trigonometric and hyperbolic functions.

import basic::{pi, tau}

### Converts degrees to radians.
fn to_radians(degrees: float64) -> float64:
    degrees * pi / 180.0

### Converts radians to degrees.
fn to_degrees(radians: float64) -> float64:
    radians * 180.0 / pi

### Returns the sine of an angle (in radians).
fn sin(x: float64) -> float64:
    # In a real implementation, use CORDIC or Taylor series
    # sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    0.0  # Placeholder

### Returns the cosine of an angle (in radians).
fn cos(x: float64) -> float64:
    # In a real implementation, use CORDIC or Taylor series
    # cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...
    0.0  # Placeholder

### Returns the tangent of an angle (in radians).
fn tan(x: float64) -> float64:
    sin(x) / cos(x)

### Returns the arcsine of x (result in radians).
fn asin(x: float64) -> float64 ! InvalidArgumentError:
    if x < -1.0 or x > 1.0:
        raise InvalidArgumentError("asin argument must be in [-1, 1]")
    # In a real implementation, use numerical approximation
    0.0  # Placeholder

### Returns the arccosine of x (result in radians).
fn acos(x: float64) -> float64 ! InvalidArgumentError:
    if x < -1.0 or x > 1.0:
        raise InvalidArgumentError("acos argument must be in [-1, 1]")
    # In a real implementation, use numerical approximation
    0.0  # Placeholder

### Returns the arctangent of x (result in radians).
fn atan(x: float64) -> float64:
    # In a real implementation, use numerical approximation
    0.0  # Placeholder

### Returns the arctangent of y/x (result in radians).
###
### This function uses the signs of both arguments to determine
### the correct quadrant of the result.
fn atan2(y: float64, x: float64) -> float64:
    if x > 0.0:
        atan(y / x)
    else if x < 0.0:
        if y >= 0.0:
            atan(y / x) + pi
        else:
            atan(y / x) - pi
    else:  # x == 0
        if y > 0.0:
            pi / 2.0
        else if y < 0.0:
            -pi / 2.0
        else:
            0.0  # Undefined, but return 0

### Returns the hyperbolic sine of x.
fn sinh(x: float64) -> float64:
    (exp(x) - exp(-x)) / 2.0

### Returns the hyperbolic cosine of x.
fn cosh(x: float64) -> float64:
    (exp(x) + exp(-x)) / 2.0

### Returns the hyperbolic tangent of x.
fn tanh(x: float64) -> float64:
    sinh(x) / cosh(x)

### Returns the inverse hyperbolic sine of x.
fn asinh(x: float64) -> float64:
    ln(x + sqrt(x * x + 1.0))

### Returns the inverse hyperbolic cosine of x.
fn acosh(x: float64) -> float64 ! InvalidArgumentError:
    if x < 1.0:
        raise InvalidArgumentError("acosh argument must be >= 1")
    ln(x + sqrt(x * x - 1.0))

### Returns the inverse hyperbolic tangent of x.
fn atanh(x: float64) -> float64 ! InvalidArgumentError:
    if x <= -1.0 or x >= 1.0:
        raise InvalidArgumentError("atanh argument must be in (-1, 1)")
    0.5 * ln((1.0 + x) / (1.0 - x))

### Returns the secant of x.
fn sec(x: float64) -> float64:
    1.0 / cos(x)

### Returns the cosecant of x.
fn csc(x: float64) -> float64:
    1.0 / sin(x)

### Returns the cotangent of x.
fn cot(x: float64) -> float64:
    cos(x) / sin(x)

### Returns the hyperbolic secant of x.
fn sech(x: float64) -> float64:
    1.0 / cosh(x)

### Returns the hyperbolic cosecant of x.
fn csch(x: float64) -> float64:
    1.0 / sinh(x)

### Returns the hyperbolic cotangent of x.
fn coth(x: float64) -> float64:
    cosh(x) / sinh(x)

### Normalizes an angle to the range [0, 2π).
fn normalize_angle_positive(x: float64) -> float64:
    let mut result = x % tau
    if result < 0.0:
        result += tau
    result

### Normalizes an angle to the range [-π, π).
fn normalize_angle_signed(x: float64) -> float64:
    let mut result = x % tau
    if result < -pi:
        result += tau
    else if result >= pi:
        result -= tau
    result

### Returns the shortest signed angle from `from` to `to`.
fn angle_difference(from: float64, to: float64) -> float64:
    normalize_angle_signed(to - from)

### Linearly interpolates between two angles (handles wraparound).
fn lerp_angle(a: float64, b: float64, t: float64) -> float64:
    let diff = angle_difference(a, b)
    normalize_angle_positive(a + diff * t)
