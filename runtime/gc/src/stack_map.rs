//! Stack Map Generation for GC Root Tracking
//!
//! This module provides stack map generation and querying functionality.
//! Stack maps are generated by the compiler to identify GC pointers on the stack
//! at every safe point (allocation site, call site, and loop back edge).
//!
//! # Stack Map Format
//!
//! ```text
//! StackMapSection
//!   ├── Header (magic, version, num_entries)
//!   └── Entries (sorted by return address)
//!         ├── StackMapEntry
//!         │     ├── return_address: u64
//!         │     ├── frame_size: u32
//!         │     ├── num_pointers: u16
//!         │     └── pointer_offsets: [u16; num_pointers]
//!         └── ...
//! ```
//!
//! The runtime uses binary search to find the correct map for a given return address.

use std::sync::atomic::{AtomicUsize, Ordering};

/// Magic number for stack map section identification
pub const STACK_MAP_MAGIC: u32 = 0x4A_53_4D_50; // "JSMP" (Jet Stack MaP)

/// Current version of the stack map format
pub const STACK_MAP_VERSION: u32 = 1;

/// Maximum number of pointer offsets per stack map entry
pub const MAX_POINTERS_PER_ENTRY: usize = 256;

/// Header for the stack map section
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StackMapHeader {
    /// Magic number for identification
    pub magic: u32,
    /// Version of the stack map format
    pub version: u32,
    /// Number of stack map entries
    pub num_entries: u32,
    /// Reserved for future use
    pub reserved: u32,
}

impl StackMapHeader {
    /// Create a new stack map header
    pub const fn new(num_entries: u32) -> Self {
        StackMapHeader {
            magic: STACK_MAP_MAGIC,
            version: STACK_MAP_VERSION,
            num_entries,
            reserved: 0,
        }
    }

    /// Verify that this is a valid stack map header
    pub fn is_valid(&self) -> bool {
        self.magic == STACK_MAP_MAGIC && self.version == STACK_MAP_VERSION
    }
}

/// A single stack map entry
///
/// This describes the GC-relevant state of the stack at a particular
/// instruction pointer (return address).
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct StackMapEntry {
    /// Return address this map applies to
    pub return_address: u64,
    /// Total frame size in bytes
    pub frame_size: u32,
    /// Number of live pointer slots
    pub num_pointers: u16,
    /// Stack map ID (for debugging)
    pub map_id: u16,
}

impl StackMapEntry {
    /// Create a new stack map entry
    pub const fn new(return_address: u64, frame_size: u32, map_id: u16) -> Self {
        StackMapEntry {
            return_address,
            frame_size,
            num_pointers: 0,
            map_id,
        }
    }

    /// Get the size of this entry including pointer offsets
    pub fn total_size(&self) -> usize {
        std::mem::size_of::<StackMapEntry>()
            + self.num_pointers as usize * std::mem::size_of::<u16>()
    }
}

/// Builder for constructing stack maps at compile time
#[derive(Debug)]
pub struct StackMapBuilder {
    /// Stack map entries being built
    entries: Vec<StackMapEntryBuilder>,
    /// Next map ID
    next_id: u16,
}

/// Builder for a single stack map entry
#[derive(Debug)]
pub struct StackMapEntryBuilder {
    /// Return address
    return_address: u64,
    /// Frame size
    frame_size: u32,
    /// Pointer offsets from frame pointer
    pointer_offsets: Vec<u16>,
    /// Map ID
    map_id: u16,
}

impl StackMapBuilder {
    /// Create a new stack map builder
    pub fn new() -> Self {
        StackMapBuilder {
            entries: Vec::new(),
            next_id: 0,
        }
    }

    /// Start building a new stack map entry
    pub fn begin_entry(&mut self, return_address: u64, frame_size: u32) -> StackMapEntryHandle {
        let map_id = self.next_id;
        self.next_id = self.next_id.wrapping_add(1);

        let entry = StackMapEntryBuilder {
            return_address,
            frame_size,
            pointer_offsets: Vec::new(),
            map_id,
        };

        let index = self.entries.len();
        self.entries.push(entry);

        StackMapEntryHandle { index }
    }

    /// Add a pointer offset to the current entry
    pub fn add_pointer(&mut self, handle: StackMapEntryHandle, offset: u16) {
        if let Some(entry) = self.entries.get_mut(handle.index) {
            entry.pointer_offsets.push(offset);
        }
    }

    /// Add multiple pointer offsets
    pub fn add_pointers(&mut self, handle: StackMapEntryHandle, offsets: &[u16]) {
        if let Some(entry) = self.entries.get_mut(handle.index) {
            entry.pointer_offsets.extend_from_slice(offsets);
        }
    }

    /// Finalize and build the stack map section
    pub fn build(mut self) -> StackMapSection {
        // Sort entries by return address for binary search
        self.entries.sort_by_key(|e| e.return_address);

        // Flatten into a single buffer
        let mut entries = Vec::with_capacity(self.entries.len());
        let mut pointer_data = Vec::new();

        for entry in self.entries {
            let num_pointers = entry.pointer_offsets.len().min(MAX_POINTERS_PER_ENTRY) as u16;

            entries.push(StackMapEntry {
                return_address: entry.return_address,
                frame_size: entry.frame_size,
                num_pointers,
                map_id: entry.map_id,
            });

            // Store pointer offsets
            for &offset in entry.pointer_offsets.iter().take(MAX_POINTERS_PER_ENTRY) {
                pointer_data.push(offset);
            }
        }

        StackMapSection {
            header: StackMapHeader::new(entries.len() as u32),
            entries,
            pointer_data,
        }
    }

    /// Get the number of entries
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Check if builder is empty
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }
}

impl Default for StackMapBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Handle to a stack map entry being built
#[derive(Debug, Clone, Copy)]
pub struct StackMapEntryHandle {
    index: usize,
}

/// Compiled stack map section
#[derive(Debug, Clone)]
pub struct StackMapSection {
    /// Section header
    pub header: StackMapHeader,
    /// Stack map entries
    pub entries: Vec<StackMapEntry>,
    /// Flattened pointer offset data
    pub pointer_data: Vec<u16>,
}

impl StackMapSection {
    /// Find the stack map entry for a given return address
    ///
    /// Uses binary search - O(log n) complexity
    pub fn find_entry(&self, return_address: u64) -> Option<&StackMapEntry> {
        self.entries
            .binary_search_by_key(&return_address, |e| e.return_address)
            .ok()
            .map(|idx| &self.entries[idx])
    }

    /// Find the stack map entry using upper bound (for any address within function)
    ///
    /// This finds the entry with the largest return_address <= given address
    pub fn find_entry_for_address(&self, address: u64) -> Option<&StackMapEntry> {
        // Binary search for the rightmost entry <= address
        let mut left = 0;
        let mut right = self.entries.len();

        while left < right {
            let mid = (left + right) / 2;
            if self.entries[mid].return_address <= address {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        if left > 0 {
            Some(&self.entries[left - 1])
        } else {
            None
        }
    }

    /// Get pointer offsets for an entry
    pub fn get_pointer_offsets(&self, entry: &StackMapEntry) -> &[u16] {
        let start = entry.map_id as usize * MAX_POINTERS_PER_ENTRY;
        let end = start + entry.num_pointers as usize;
        &self.pointer_data[start..end.min(self.pointer_data.len())]
    }

    /// Serialize the stack map section to bytes
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();

        // Header
        bytes.extend_from_slice(&self.header.magic.to_le_bytes());
        bytes.extend_from_slice(&self.header.version.to_le_bytes());
        bytes.extend_from_slice(&self.header.num_entries.to_le_bytes());
        bytes.extend_from_slice(&self.header.reserved.to_le_bytes());

        // Entries
        for entry in &self.entries {
            bytes.extend_from_slice(&entry.return_address.to_le_bytes());
            bytes.extend_from_slice(&entry.frame_size.to_le_bytes());
            bytes.extend_from_slice(&entry.num_pointers.to_le_bytes());
            bytes.extend_from_slice(&entry.map_id.to_le_bytes());
        }

        // Pointer data
        for &offset in &self.pointer_data {
            bytes.extend_from_slice(&offset.to_le_bytes());
        }

        bytes
    }

    /// Deserialize a stack map section from bytes
    pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
        if bytes.len() < std::mem::size_of::<StackMapHeader>() {
            return None;
        }

        let mut offset = 0;

        // Read header
        let magic = u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
        let version = u32::from_le_bytes([bytes[4], bytes[5], bytes[6], bytes[7]]);
        let num_entries = u32::from_le_bytes([bytes[8], bytes[9], bytes[10], bytes[11]]);
        let reserved = u32::from_le_bytes([bytes[12], bytes[13], bytes[14], bytes[15]]);

        let header = StackMapHeader {
            magic,
            version,
            num_entries,
            reserved,
        };

        if !header.is_valid() {
            return None;
        }

        offset += 16;

        // Read entries
        let mut entries = Vec::with_capacity(num_entries as usize);
        for _ in 0..num_entries {
            if offset + 16 > bytes.len() {
                return None;
            }

            let return_address = u64::from_le_bytes([
                bytes[offset],
                bytes[offset + 1],
                bytes[offset + 2],
                bytes[offset + 3],
                bytes[offset + 4],
                bytes[offset + 5],
                bytes[offset + 6],
                bytes[offset + 7],
            ]);
            let frame_size = u32::from_le_bytes([
                bytes[offset + 8],
                bytes[offset + 9],
                bytes[offset + 10],
                bytes[offset + 11],
            ]);
            let num_pointers = u16::from_le_bytes([bytes[offset + 12], bytes[offset + 13]]);
            let map_id = u16::from_le_bytes([bytes[offset + 14], bytes[offset + 15]]);

            entries.push(StackMapEntry {
                return_address,
                frame_size,
                num_pointers,
                map_id,
            });

            offset += 16;
        }

        // Read pointer data (remaining bytes)
        let mut pointer_data = Vec::new();
        while offset + 2 <= bytes.len() {
            let ptr_offset = u16::from_le_bytes([bytes[offset], bytes[offset + 1]]);
            pointer_data.push(ptr_offset);
            offset += 2;
        }

        Some(StackMapSection {
            header,
            entries,
            pointer_data,
        })
    }
}

/// Runtime stack map registry
///
/// This holds all stack maps for the program and provides thread-safe
/// lookup during GC root scanning.
pub struct StackMapRegistry {
    /// Registered stack map sections
    sections: Vec<StackMapSection>,
    /// Total number of entries
    total_entries: AtomicUsize,
}

impl StackMapRegistry {
    /// Create a new empty registry
    pub fn new() -> Self {
        StackMapRegistry {
            sections: Vec::new(),
            total_entries: AtomicUsize::new(0),
        }
    }

    /// Register a stack map section
    pub fn register(&mut self, section: StackMapSection) {
        self.total_entries
            .fetch_add(section.entries.len(), Ordering::Relaxed);
        self.sections.push(section);
    }

    /// Find a stack map entry for the given return address
    pub fn find_entry(&self, return_address: u64) -> Option<(&StackMapSection, &StackMapEntry)> {
        for section in &self.sections {
            if let Some(entry) = section.find_entry(return_address) {
                return Some((section, entry));
            }
        }
        None
    }

    /// Find the best matching entry for an address (using upper bound)
    pub fn find_entry_for_address(
        &self,
        address: u64,
    ) -> Option<(&StackMapSection, &StackMapEntry)> {
        for section in &self.sections {
            if let Some(entry) = section.find_entry_for_address(address) {
                return Some((section, entry));
            }
        }
        None
    }

    /// Get total number of registered entries
    pub fn total_entries(&self) -> usize {
        self.total_entries.load(Ordering::Relaxed)
    }

    /// Clear all registered sections
    pub fn clear(&mut self) {
        self.sections.clear();
        self.total_entries.store(0, Ordering::Relaxed);
    }
}

impl Default for StackMapRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// Iterator over GC roots in a stack frame
pub struct GcRootIterator<'a> {
    /// Base pointer of the frame
    frame_base: *mut u8,
    /// Pointer offsets
    offsets: &'a [u16],
    /// Current index
    current: usize,
}

impl<'a> GcRootIterator<'a> {
    /// Create a new GC root iterator
    ///
    /// # Safety
    /// The frame_base must be a valid frame pointer, and the offsets
    /// must correctly identify GC pointers within that frame.
    pub unsafe fn new(frame_base: *mut u8, offsets: &'a [u16]) -> Self {
        GcRootIterator {
            frame_base,
            offsets,
            current: 0,
        }
    }

    /// Get the number of roots
    pub fn len(&self) -> usize {
        self.offsets.len()
    }

    /// Check if there are no roots
    pub fn is_empty(&self) -> bool {
        self.offsets.is_empty()
    }
}

impl<'a> Iterator for GcRootIterator<'a> {
    type Item = *mut *mut u8;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current >= self.offsets.len() {
            return None;
        }

        let offset = self.offsets[self.current] as usize;
        self.current += 1;

        Some(unsafe { self.frame_base.add(offset) as *mut *mut u8 })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_stack_map_header() {
        let header = StackMapHeader::new(10);
        assert!(header.is_valid());
        assert_eq!(header.magic, STACK_MAP_MAGIC);
        assert_eq!(header.version, STACK_MAP_VERSION);
        assert_eq!(header.num_entries, 10);
    }

    #[test]
    fn test_stack_map_builder() {
        let mut builder = StackMapBuilder::new();

        // Create first entry
        let handle1 = builder.begin_entry(0x1000, 64);
        builder.add_pointer(handle1, 8);
        builder.add_pointer(handle1, 16);

        // Create second entry
        let handle2 = builder.begin_entry(0x2000, 128);
        builder.add_pointer(handle2, 24);

        let section = builder.build();

        assert_eq!(section.entries.len(), 2);
        assert_eq!(section.entries[0].num_pointers, 2);
        assert_eq!(section.entries[1].num_pointers, 1);
    }

    #[test]
    fn test_find_entry() {
        let mut builder = StackMapBuilder::new();

        builder.begin_entry(0x1000, 64);
        builder.begin_entry(0x2000, 128);
        builder.begin_entry(0x3000, 256);

        let section = builder.build();

        assert!(section.find_entry(0x1000).is_some());
        assert!(section.find_entry(0x2000).is_some());
        assert!(section.find_entry(0x1500).is_none());
    }

    #[test]
    fn test_find_entry_for_address() {
        let mut builder = StackMapBuilder::new();

        builder.begin_entry(0x1000, 64);
        builder.begin_entry(0x2000, 128);
        builder.begin_entry(0x3000, 256);

        let section = builder.build();

        // Should find the entry with largest address <= given address
        let entry = section.find_entry_for_address(0x1500).unwrap();
        assert_eq!(entry.return_address, 0x1000);

        let entry = section.find_entry_for_address(0x2500).unwrap();
        assert_eq!(entry.return_address, 0x2000);
    }

    #[test]
    fn test_serialization() {
        let mut builder = StackMapBuilder::new();

        let handle = builder.begin_entry(0x1000, 64);
        builder.add_pointer(handle, 8);
        builder.add_pointer(handle, 16);

        let section = builder.build();
        let bytes = section.to_bytes();
        let restored = StackMapSection::from_bytes(&bytes).unwrap();

        assert_eq!(restored.header.num_entries, 1);
        assert_eq!(restored.entries[0].return_address, 0x1000);
        assert_eq!(restored.entries[0].num_pointers, 2);
    }

    #[test]
    fn test_invalid_header() {
        let bytes = vec![0u8; 16];
        assert!(StackMapSection::from_bytes(&bytes).is_none());
    }

    #[test]
    fn test_stack_map_registry() {
        let mut registry = StackMapRegistry::new();

        let mut builder = StackMapBuilder::new();
        builder.begin_entry(0x1000, 64);
        let section = builder.build();

        registry.register(section);

        assert_eq!(registry.total_entries(), 1);
        assert!(registry.find_entry(0x1000).is_some());
        assert!(registry.find_entry(0x2000).is_none());
    }

    #[test]
    fn test_gc_root_iterator() {
        let offsets = [8u16, 16, 24];
        let frame: [u64; 4] = [0, 0x1000, 0x2000, 0x3000];

        unsafe {
            let iter = GcRootIterator::new(frame.as_ptr() as *mut u8, &offsets);
            assert_eq!(iter.len(), 3);

            let roots: Vec<_> = iter.collect();
            assert_eq!(roots.len(), 3);
        }
    }
}
