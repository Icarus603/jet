//! Jet Literate Programming Support
//!
//! This crate provides literate programming capabilities for Jet, including:
//! - Weaving: Generating documentation from literate source files
//! - Tangling: Extracting executable code from literate source files
//!
//! Literate Jet files use the `.ljt` extension or `.jet.md` for markdown-embedded code.

use jet_lexer::{Span, SpannedToken, Token};
use jet_parser::ast::{Example, Module, ModuleItem, Spec};
use jet_parser::Parser;

pub mod error;

use error::{LiterateError, LiterateResult};

/// A literate programming document that can be woven or tangled
#[derive(Debug, Clone)]
pub struct LiterateDocument {
    /// The original source text
    pub source: String,
    /// The parsed AST module
    pub module: Module,
    /// Markdown sections extracted from doc comments
    pub markdown_sections: Vec<MarkdownSection>,
    /// Specifications extracted from @spec annotations
    pub specs: Vec<Spec>,
    /// Examples extracted from @example annotations
    pub examples: Vec<Example>,
}

/// A markdown section extracted from a doc comment
#[derive(Debug, Clone)]
pub struct MarkdownSection {
    /// The markdown content (without the ### prefix)
    pub content: String,
    /// The source span
    pub span: Span,
    /// Header level (1-6) if this is a header
    pub header_level: Option<u8>,
}

/// Options for weaving documentation
#[derive(Debug, Clone, Default)]
pub struct WeaveOptions {
    /// Include source code in the output
    pub include_code: bool,
    /// Include specifications
    pub include_specs: bool,
    /// Include examples
    pub include_examples: bool,
    /// Output format
    pub format: OutputFormat,
}

/// Output format for woven documentation
#[derive(Debug, Clone, Default)]
pub enum OutputFormat {
    #[default]
    Markdown,
    Html,
    Latex,
}

/// Options for tangling code
#[derive(Debug, Clone, Default)]
pub struct TangleOptions {
    /// Include @spec annotations as comments
    pub include_specs: bool,
    /// Include @example code
    pub include_examples: bool,
    /// Generate test functions for @spec and @example
    pub generate_tests: bool,
}

impl LiterateDocument {
    /// Parse a literate Jet source file
    pub fn parse(source: impl Into<String>) -> LiterateResult<Self> {
        let source = source.into();
        let tokens = jet_lexer::tokenize(&source);

        // Extract markdown sections from doc comments before parsing
        let markdown_sections = Self::extract_markdown_sections(&tokens);

        // Parse the module
        let mut parser = Parser::new(tokens);
        let module = parser
            .parse_module()
            .map_err(|e| LiterateError::ParseError(e.to_string()))?;

        // Extract specs and examples
        let specs = Self::extract_specs(&module);
        let examples = Self::extract_examples(&module);

        Ok(LiterateDocument {
            source,
            module,
            markdown_sections,
            specs,
            examples,
        })
    }

    /// Parse a markdown-embedded Jet file (.jet.md)
    pub fn parse_markdown(source: impl Into<String>) -> LiterateResult<Self> {
        let source = source.into();

        // Extract code blocks from markdown
        let code_blocks = Self::extract_code_blocks(&source);

        // Concatenate code blocks into a single Jet source
        let jet_source = code_blocks.join("\n\n");

        Self::parse(jet_source)
    }

    /// Weave the document into documentation
    pub fn weave(&self, options: &WeaveOptions) -> String {
        match options.format {
            OutputFormat::Markdown => self.weave_markdown(options),
            OutputFormat::Html => self.weave_html(options),
            OutputFormat::Latex => self.weave_latex(options),
        }
    }

    /// Tangle the document into executable Jet code
    pub fn tangle(&self, options: &TangleOptions) -> String {
        let mut output = String::new();

        // Add header comment
        output.push_str("# Generated by Jet Literate Programming\n");
        output.push_str("# This file was generated from a literate source file.\n");
        output.push_str("# Do not edit directly - modify the source instead.\n\n");

        // Add specs as comments if requested
        if options.include_specs {
            for spec in &self.specs {
                output.push_str("# ");
                output.push_str(&spec.description);
                output.push('\n');
                if let Some(func) = &spec.test_for {
                    output.push_str("# @test_for(");
                    output.push_str(func);
                    output.push_str(")\n");
                }
                output.push('\n');
            }
        }

        // Add the main module code
        for item in &self.module.items {
            match item {
                ModuleItem::Spec(_) | ModuleItem::Example(_) => {
                    // Skip literate-specific items in basic tangle
                    if options.generate_tests {
                        // Test stubs are appended in a dedicated section below.
                    }
                }
                _ => {
                    let span = module_item_span(item);
                    let code = self.source_for_span(span);
                    if !code.trim().is_empty() {
                        output.push_str(code.trim());
                        output.push_str("\n\n");
                    }
                }
            }
        }

        // Add examples as code if requested
        if options.include_examples {
            for (i, example) in self.examples.iter().enumerate() {
                if let Some(caption) = &example.caption {
                    output.push_str("# Example: ");
                    output.push_str(caption);
                    output.push('\n');
                } else {
                    output.push_str("# Example ");
                    output.push_str(&(i + 1).to_string());
                    output.push('\n');
                }
                output.push_str("# ");
                output.push_str(&self.example_code_to_string(example));
                output.push('\n');
            }
        }

        if options.generate_tests {
            output.push_str("\n# Generated tests from literate specs/examples\n");
            for (i, spec) in self.specs.iter().enumerate() {
                let test_name = spec
                    .test_for
                    .as_ref()
                    .map(|n| format!("test_spec_{}_{}", i + 1, sanitize_ident(n)))
                    .unwrap_or_else(|| format!("test_spec_{}", i + 1));
                output.push_str("fn ");
                output.push_str(&test_name);
                output.push_str("():\n    pass\n\n");
            }
            for (i, example) in self.examples.iter().enumerate() {
                let test_name = example
                    .test_for
                    .as_ref()
                    .map(|n| format!("test_example_{}_{}", i + 1, sanitize_ident(n)))
                    .unwrap_or_else(|| format!("test_example_{}", i + 1));
                output.push_str("fn ");
                output.push_str(&test_name);
                output.push_str("():\n    pass\n\n");
            }
        }

        output
    }

    /// Extract markdown sections from doc comment tokens
    fn extract_markdown_sections(tokens: &[SpannedToken]) -> Vec<MarkdownSection> {
        let mut sections = Vec::new();

        for token in tokens {
            if let Token::DocComment(content) = &token.token {
                let header_level = Self::detect_header_level(content);

                sections.push(MarkdownSection {
                    content: content.clone(),
                    span: token.span,
                    header_level,
                });
            }
        }

        sections
    }

    /// Detect if a doc comment contains a markdown header
    fn detect_header_level(content: &str) -> Option<u8> {
        let trimmed = content.trim_start();
        let mut level = 0u8;

        for ch in trimmed.chars() {
            if ch == '#' {
                level += 1;
                if level > 6 {
                    return None; // Not a valid header
                }
            } else if ch.is_whitespace() {
                if level > 0 {
                    return Some(level);
                }
                return None;
            } else {
                return None;
            }
        }

        None
    }

    /// Extract code blocks from markdown source
    fn extract_code_blocks(source: &str) -> Vec<String> {
        let mut blocks = Vec::new();
        let mut in_code_block = false;
        let mut current_block = String::new();
        let mut is_jet_block = false;

        for line in source.lines() {
            let trimmed = line.trim();

            if trimmed.starts_with("```") {
                if in_code_block {
                    // End of code block
                    if is_jet_block {
                        blocks.push(current_block.trim().to_string());
                    }
                    current_block.clear();
                    in_code_block = false;
                    is_jet_block = false;
                } else {
                    // Start of code block
                    in_code_block = true;
                    is_jet_block =
                        trimmed.contains("jet") || trimmed == "```" || trimmed.contains("rust");
                }
            } else if in_code_block {
                current_block.push_str(line);
                current_block.push('\n');
            }
        }

        blocks
    }

    /// Extract specs from the module
    fn extract_specs(module: &Module) -> Vec<Spec> {
        module
            .items
            .iter()
            .filter_map(|item| match item {
                ModuleItem::Spec(spec) => Some(spec.clone()),
                _ => None,
            })
            .collect()
    }

    /// Extract examples from the module
    fn extract_examples(module: &Module) -> Vec<Example> {
        module
            .items
            .iter()
            .filter_map(|item| match item {
                ModuleItem::Example(example) => Some(example.clone()),
                _ => None,
            })
            .collect()
    }

    fn source_for_span(&self, span: Span) -> &str {
        let start = span.start.min(self.source.len());
        let end = span.end.min(self.source.len());
        if start >= end {
            ""
        } else {
            &self.source[start..end]
        }
    }

    fn example_code_to_string(&self, example: &Example) -> String {
        // Use a stable textual representation until a dedicated pretty-printer exists.
        format!("{:?}", example.code)
    }

    /// Weave as Markdown
    fn weave_markdown(&self, _options: &WeaveOptions) -> String {
        let mut output = String::new();

        // Add title if there's a level-1 header
        for section in &self.markdown_sections {
            if section.header_level == Some(1) {
                output.push_str("# ");
                output.push_str(section.content.trim_start_matches('#').trim());
                output.push_str("\n\n");
                break;
            }
        }

        // Add all markdown sections
        for section in &self.markdown_sections {
            if section.header_level != Some(1) {
                output.push_str(section.content.trim());
                output.push_str("\n\n");
            }
        }

        // Add specs section
        if !self.specs.is_empty() {
            output.push_str("## Specifications\n\n");
            for (i, spec) in self.specs.iter().enumerate() {
                output.push_str(&format!("{}. {}", i + 1, spec.description));
                output.push('\n');
                if let Some(func) = &spec.test_for {
                    output.push_str(&format!("   - *Tests for: `{}`*", func));
                    output.push('\n');
                }
                output.push('\n');
            }
        }

        // Add examples section
        if !self.examples.is_empty() {
            output.push_str("## Examples\n\n");
            for (i, example) in self.examples.iter().enumerate() {
                if let Some(caption) = &example.caption {
                    output.push_str(&format!("### Example {}: {}\n\n", i + 1, caption));
                } else {
                    output.push_str(&format!("### Example {}\n\n", i + 1));
                }
                if let Some(func) = &example.test_for {
                    output.push_str(&format!("*Tests for: `{}`*\n\n", func));
                }
                output.push_str("```jet\n");
                output.push_str(&self.example_code_to_string(example));
                output.push('\n');
                output.push_str("```\n\n");
            }
        }

        output
    }

    /// Weave as HTML
    fn weave_html(&self, options: &WeaveOptions) -> String {
        let markdown = self.weave_markdown(options);
        // Simple markdown to HTML conversion
        // In a real implementation, use a proper markdown parser
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>Literate Jet Document</title>
</head>
<body>
<pre>{}<pre>
</body>
</html>
"#,
            html_escape(&markdown)
        )
    }

    /// Weave as LaTeX
    fn weave_latex(&self, _options: &WeaveOptions) -> String {
        let mut output = String::new();

        output.push_str("\\documentclass{article}\n");
        output.push_str("\\usepackage{listings}\n");
        output.push_str("\\usepackage{xcolor}\n");
        output.push_str("\\begin{document}\n\n");

        // Add title
        for section in &self.markdown_sections {
            if section.header_level == Some(1) {
                output.push_str("\\title{");
                output.push_str(&latex_escape(
                    section.content.trim_start_matches('#').trim(),
                ));
                output.push_str("}\n");
                output.push_str("\\maketitle\n\n");
                break;
            }
        }

        // Add sections
        for section in &self.markdown_sections {
            if let Some(level) = section.header_level {
                if level > 1 {
                    let cmd = match level {
                        2 => "\\section",
                        3 => "\\subsection",
                        4 => "\\subsubsection",
                        5 => "\\paragraph",
                        _ => "\\subparagraph",
                    };
                    output.push_str(cmd);
                    output.push('{');
                    output.push_str(&latex_escape(
                        section.content.trim_start_matches('#').trim(),
                    ));
                    output.push_str("}\n\n");
                }
            } else {
                output.push_str(&latex_escape(section.content.trim()));
                output.push_str("\n\n");
            }
        }

        output.push_str("\\end{document}\n");
        output
    }
}

fn module_item_span(item: &ModuleItem) -> Span {
    match item {
        ModuleItem::Import(import) => match import {
            jet_parser::ast::Import::Simple { path, .. } => path.span,
            jet_parser::ast::Import::From { path, .. } => path.span,
        },
        ModuleItem::Function(func) => func.span,
        ModuleItem::Struct(struct_def) => struct_def.span,
        ModuleItem::Enum(enum_def) => enum_def.span,
        ModuleItem::Trait(trait_def) => trait_def.span,
        ModuleItem::Impl(impl_def) => impl_def.span,
        ModuleItem::TypeAlias(type_alias) => type_alias.span,
        ModuleItem::Const(const_def) => const_def.span,
        ModuleItem::Effect(effect_def) => effect_def.span,
        ModuleItem::Spec(spec) => spec.span,
        ModuleItem::Example(example) => example.span,
        ModuleItem::GhostType(ghost_type) => ghost_type.span,
    }
}

fn sanitize_ident(input: &str) -> String {
    let mut out = String::with_capacity(input.len());
    for ch in input.chars() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            out.push(ch);
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        "generated".to_string()
    } else {
        out
    }
}

/// Simple HTML escaping
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

/// Simple LaTeX escaping
fn latex_escape(s: &str) -> String {
    s.replace('\\', "\\textbackslash{}")
        .replace('{', "\\{")
        .replace('}', "\\}")
        .replace('$', "\\$")
        .replace('&', "\\&")
        .replace('%', "\\%")
        .replace('#', "\\#")
        .replace('_', "\\_")
        .replace('^', "\\^{}")
        .replace('~', "\\textasciitilde{}")
}

/// Parse and weave a literate Jet file
pub fn weave(source: &str, options: &WeaveOptions) -> LiterateResult<String> {
    let doc = LiterateDocument::parse(source)?;
    Ok(doc.weave(options))
}

/// Parse and tangle a literate Jet file
pub fn tangle(source: &str, options: &TangleOptions) -> LiterateResult<String> {
    let doc = LiterateDocument::parse(source)?;
    Ok(doc.tangle(options))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_header_level() {
        assert_eq!(LiterateDocument::detect_header_level("# Header"), Some(1));
        assert_eq!(
            LiterateDocument::detect_header_level("## Subheader"),
            Some(2)
        );
        assert_eq!(
            LiterateDocument::detect_header_level("###### Deep"),
            Some(6)
        );
        assert_eq!(
            LiterateDocument::detect_header_level("####### Too deep"),
            None
        );
        assert_eq!(LiterateDocument::detect_header_level("Not a header"), None);
    }

    #[test]
    fn test_extract_code_blocks() {
        let markdown = r#"
# Title

Some text.

```jet
fn main() {
    println("Hello")
}
```

More text.

```
let x = 5
```
"#;

        let blocks = LiterateDocument::extract_code_blocks(markdown);
        assert_eq!(blocks.len(), 2);
        assert!(blocks[0].contains("fn main()"));
        assert!(blocks[1].contains("let x = 5"));
    }

    #[test]
    fn test_html_escape() {
        assert_eq!(html_escape("<div>"), "&lt;div&gt;");
        assert_eq!(html_escape("foo & bar"), "foo &amp; bar");
    }

    #[test]
    fn test_latex_escape() {
        assert_eq!(latex_escape("foo_bar"), "foo\\_bar");
        assert_eq!(latex_escape("100%"), "100\\%");
    }
}
