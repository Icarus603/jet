//! Jet Language Parser
//!
//! A recursive descent parser that builds an AST from jet tokens.

pub mod ast;
pub mod error;

use ast::*;
use error::{ParseError, ParseErrorKind, ParseResult};
use jet_lexer::{Span, SpannedToken, Token};

/// The parser struct
pub struct Parser {
    tokens: Vec<SpannedToken>,
    position: usize,
}

impl Parser {
    /// Create a new parser from a list of tokens
    pub fn new(tokens: Vec<SpannedToken>) -> Self {
        Self {
            tokens,
            position: 0,
        }
    }

    /// Parse a complete module
    pub fn parse_module(&mut self) -> ParseResult<Module> {
        let start_span = self.current_span();
        let mut items = Vec::new();

        while !self.is_at_end() {
            self.skip_newlines();
            if self.is_at_end() {
                break;
            }

            match self.parse_module_item() {
                Ok(item) => items.push(item),
                Err(e) => {
                    // Error recovery: skip to next statement
                    self.recover_to_next_item();
                    return Err(e);
                }
            }
        }

        let end_span = self.current_span();
        Ok(Module {
            attributes: Vec::new(),
            items,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a module-level item
    fn parse_module_item(&mut self) -> ParseResult<ModuleItem> {
        // Check for visibility
        let public = self.match_token(&Token::Pub);

        match self.peek() {
            Some(Token::Import) | Some(Token::From) => {
                if public {
                    // pub import is valid for re-exports
                }
                self.parse_import().map(ModuleItem::Import)
            }
            Some(Token::Fn) => self.parse_function(public).map(ModuleItem::Function),
            Some(Token::Struct) => self.parse_struct(public).map(ModuleItem::Struct),
            Some(Token::Enum) => self.parse_enum(public).map(ModuleItem::Enum),
            Some(Token::Trait) => self.parse_trait(public).map(ModuleItem::Trait),
            Some(Token::Impl) => self.parse_impl().map(ModuleItem::Impl),
            Some(Token::Type) => self.parse_type_alias(public).map(ModuleItem::TypeAlias),
            Some(Token::Const) => {
                // Const definition at module level
                self.parse_const_def(public).map(ModuleItem::Const)
            }
            Some(Token::Let) => {
                // Let binding at module level (treated as const)
                self.parse_const_def(public).map(ModuleItem::Const)
            }
            Some(Token::Async) => {
                // Async function
                self.advance(); // consume async
                self.parse_function(public).map(ModuleItem::Function)
            }
            Some(Token::Effect) => self.parse_effect_def(public).map(ModuleItem::Effect),
            Some(Token::AtSpec) => self.parse_spec().map(ModuleItem::Spec),
            Some(Token::AtExample) => self.parse_example().map(ModuleItem::Example),
            Some(token) => Err(ParseError::unexpected_token(
                "module item",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof(
                "module item",
                self.current_span(),
            )),
        }
    }

    /// Parse an import statement
    fn parse_import(&mut self) -> ParseResult<Import> {
        // Check for `from` style import first: `from path import items`
        if self.check(&Token::From) {
            self.advance();
            let path = self.parse_import_path()?;
            self.consume(Token::Import, "import")?;
            let items = self.parse_import_items()?;
            return Ok(Import::From { path, items });
        }

        self.consume(Token::Import, "import")?;

        // Simple import: `import path` or `import path as name`
        let path = self.parse_import_path()?;
        let alias = if self.match_token(&Token::As) {
            Some(self.parse_identifier()?)
        } else {
            None
        };

        Ok(Import::Simple { path, alias })
    }

    /// Parse an import path (supports both `::` and `.` as separators)
    fn parse_import_path(&mut self) -> ParseResult<Path> {
        let start_span = self.current_span();
        let mut segments = Vec::new();

        loop {
            segments.push(self.parse_identifier()?);

            // Accept either `::` or `.` as path separator for imports
            if !self.match_token(&Token::ColonColon) && !self.match_token(&Token::Dot) {
                break;
            }
        }

        let end_span = self.current_span();
        Ok(Path::new(
            segments,
            Span::new(start_span.start, end_span.end),
        ))
    }

    /// Parse import items for `from ... import ...`
    fn parse_import_items(&mut self) -> ParseResult<Vec<ImportItem>> {
        let mut items = Vec::new();

        // Check for group import `{ a, b, c }`
        if self.match_token(&Token::LBrace) {
            if !self.check(&Token::RBrace) {
                loop {
                    items.push(self.parse_import_item()?);
                    if !self.match_token(&Token::Comma) {
                        break;
                    }
                }
            }
            self.consume(Token::RBrace, "`}`")?;
        } else {
            // Single or comma-separated items
            loop {
                items.push(self.parse_import_item()?);
                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        Ok(items)
    }

    /// Parse a single import item
    fn parse_import_item(&mut self) -> ParseResult<ImportItem> {
        let name = self.parse_identifier()?;
        let alias = if self.match_token(&Token::As) {
            Some(self.parse_identifier()?)
        } else {
            None
        };

        Ok(ImportItem::Single { name, alias })
    }

    /// Parse a function definition
    fn parse_function(&mut self, public: bool) -> ParseResult<Function> {
        let start_span = self.current_span();
        self.consume(Token::Fn, "`fn`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Parameters
        self.consume(Token::LParen, "`(`")?;
        let params = self.parse_params()?;
        self.consume(Token::RParen, "`)`")?;

        // Return type
        let return_type = if self.match_token(&Token::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };

        // Effects
        let effects = if self.match_token(&Token::Bang) {
            self.parse_effects()?
        } else {
            Vec::new()
        };

        // Where clause
        let where_clause = if self.check(&Token::Where) {
            self.parse_where_clause()?
        } else {
            Vec::new()
        };

        // Body
        let body = self.parse_block_or_expr()?;

        let end_span = self.current_span();
        Ok(Function {
            public,
            attributes: Vec::new(),
            name,
            generics,
            params,
            return_type,
            effects,
            where_clause,
            contract: self.parse_contract_clause()?,
            body,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse generic parameters
    fn parse_generic_params(&mut self) -> ParseResult<Vec<GenericParam>> {
        let mut params = Vec::new();

        if !self.check(&Token::RBracket) {
            loop {
                let name = self.parse_identifier()?;

                // Parse bounds: `T: Bound1 + Bound2`
                let bounds = if self.match_token(&Token::Colon) {
                    self.parse_type_bounds()?
                } else {
                    Vec::new()
                };

                params.push(GenericParam { name, bounds });

                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        Ok(params)
    }

    /// Parse type bounds separated by `+`
    fn parse_type_bounds(&mut self) -> ParseResult<Vec<Type>> {
        let mut bounds = Vec::new();

        loop {
            bounds.push(self.parse_type()?);
            if !(self.match_token(&Token::Plus) || self.match_token(&Token::OrBit)) {
                break;
            }
        }

        Ok(bounds)
    }

    /// Parse function parameters
    fn parse_params(&mut self) -> ParseResult<Vec<Param>> {
        let mut params = Vec::new();

        if !self.check(&Token::RParen) {
            loop {
                let param = self.parse_param()?;
                params.push(param);

                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        Ok(params)
    }

    /// Parse a single parameter
    fn parse_param(&mut self) -> ParseResult<Param> {
        // Check for self parameter
        if let Some(Token::Self_) = self.peek() {
            self.advance();
            let span = self.current_span();
            let pattern = Pattern::Ident {
                mutable: false,
                name: Ident::new("self", span),
            };
            // Self parameter has no type annotation in simple form
            return Ok(Param {
                pattern,
                ty: Type::SelfType,
            });
        }

        // Check for &self or &mut self
        if self.check(&Token::AndBit) {
            let span = self.current_span();
            self.advance();
            let mutable = self.match_token(&Token::Mut);

            if let Some(Token::Self_) = self.peek() {
                self.advance();
                let pattern = Pattern::Ident {
                    mutable,
                    name: Ident::new("self", span),
                };
                return Ok(Param {
                    pattern,
                    ty: Type::Reference {
                        mutable,
                        inner: Box::new(Type::SelfType),
                    },
                });
            }

            // It's a reference pattern, not self
            // Need to backtrack or handle differently
            // For now, treat as regular param
        }

        // Regular parameter: pattern [: Type]
        let pattern = self.parse_pattern()?;
        let ty = if self.match_token(&Token::Colon) {
            self.parse_type()?
        } else {
            Type::Infer
        };

        Ok(Param { pattern, ty })
    }

    /// Parse effects (e.g., `! Error1 | Error2 | async`)
    fn parse_effects(&mut self) -> ParseResult<Vec<Type>> {
        let mut effects = Vec::new();

        // Parse first effect
        effects.push(self.parse_effect()?);

        // Parse additional effects separated by |
        while self.match_token(&Token::OrBit) {
            effects.push(self.parse_effect()?);
        }

        Ok(effects)
    }

    /// Parse a single effect
    fn parse_effect(&mut self) -> ParseResult<Type> {
        // Special effects: async, io, unsafe
        if let Some(token) = self.peek() {
            match token {
                Token::Async => {
                    self.advance();
                    let span = self.current_span();
                    return Ok(Type::Path(Path::single(Ident::new("async", span))));
                }
                Token::Ident(name) => {
                    if name == "io" || name == "unsafe" {
                        let name = name.clone();
                        let span = self.current_span();
                        self.advance();
                        return Ok(Type::Path(Path::single(Ident::new(name, span))));
                    }
                }
                _ => {}
            }
        }

        // Regular path-based effect
        self.parse_type()
    }

    /// Parse where clause
    fn parse_where_clause(&mut self) -> ParseResult<Vec<WhereBound>> {
        self.consume(Token::Where, "`where`")?;

        let mut bounds = Vec::new();

        loop {
            let ty = self.parse_type()?;
            self.consume(Token::Colon, "`:`")?;
            let type_bounds = self.parse_type_bounds()?;

            bounds.push(WhereBound {
                ty,
                bounds: type_bounds,
            });

            if !self.match_token(&Token::Comma) {
                break;
            }
        }

        Ok(bounds)
    }

    /// Parse a block or expression (for function body)
    fn parse_block_or_expr(&mut self) -> ParseResult<Expr> {
        if self.check(&Token::Colon) {
            // Indentation-based block
            self.advance();
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let block = self.parse_block_internal()?;
            self.consume(Token::Dedent, "dedentation")?;
            Ok(Expr::Block(block))
        } else if self.check(&Token::Arrow) {
            // Expression body: `-> expr`
            self.advance();
            self.parse_expr()
        } else {
            Err(ParseError::unexpected_token(
                "`:` or `->`",
                self.peek().unwrap_or(&Token::Eof),
                self.current_span(),
            ))
        }
    }

    /// Parse a struct definition
    fn parse_struct(&mut self, public: bool) -> ParseResult<StructDef> {
        let start_span = self.current_span();
        self.consume(Token::Struct, "`struct`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Check for tuple struct: `struct Point(f64, f64)`
        if self.check(&Token::LParen) {
            return self.parse_tuple_struct(start_span, public, name, generics);
        }

        // Body
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();

        // Check for empty struct (no indentation needed if followed by another item or EOF)
        if !self.check(&Token::Indent) {
            // Empty struct
            let end_span = self.current_span();
            return Ok(StructDef {
                public,
                attributes: Vec::new(),
                name,
                generics,
                fields: Vec::new(),
                span: Span::new(start_span.start, end_span.end),
            });
        }

        self.consume(Token::Indent, "indentation")?;

        let mut fields = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            if self.match_token(&Token::Pass) {
                self.skip_newlines();
                break;
            }
            let field_public = self.match_token(&Token::Pub);
            let field_name = self.parse_identifier()?;
            self.consume(Token::Colon, "`:`")?;
            let field_ty = self.parse_type()?;

            fields.push(FieldDef {
                public: field_public,
                name: field_name,
                ty: field_ty,
            });

            self.skip_newlines();
        }

        self.consume(Token::Dedent, "dedentation")?;

        let end_span = self.current_span();
        Ok(StructDef {
            public,
            attributes: Vec::new(),
            name,
            generics,
            fields,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a tuple struct definition: `struct Point(f64, f64)`
    fn parse_tuple_struct(
        &mut self,
        start_span: Span,
        public: bool,
        name: Ident,
        generics: Vec<GenericParam>,
    ) -> ParseResult<StructDef> {
        self.consume(Token::LParen, "`(`")?;

        let mut fields = Vec::new();

        // Parse tuple field types
        while !self.check(&Token::RParen) && !self.is_at_end() {
            let field_ty = self.parse_type()?;

            // Create a synthetic field name based on position (_0, _1, etc.)
            let field_name = Ident::new(format!("_{}", fields.len()), self.current_span());

            fields.push(FieldDef {
                public: false,
                name: field_name,
                ty: field_ty,
            });

            // Allow trailing comma
            if !self.match_token(&Token::Comma) {
                break;
            }
        }

        self.consume(Token::RParen, "`)`")?;

        let end_span = self.current_span();
        Ok(StructDef {
            public,
            attributes: Vec::new(),
            name,
            generics,
            fields,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse an enum definition
    fn parse_enum(&mut self, public: bool) -> ParseResult<EnumDef> {
        let start_span = self.current_span();
        self.consume(Token::Enum, "`enum`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Body
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;

        let mut variants = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            self.consume(Token::OrBit, "`|`")?; // Each variant starts with |
            let variant_name = self.parse_identifier()?;

            // Variant body
            let body = if self.check(&Token::LParen) {
                // Tuple variant
                self.advance();
                let types = self.parse_tuple_types()?;
                self.consume(Token::RParen, "`)`")?;
                VariantBody::Tuple(types)
            } else if self.check(&Token::LBrace) {
                // Brace-style struct variant: `| Some { value: T }`
                self.advance();
                let fields = self.parse_brace_struct_fields()?;
                self.consume(Token::RBrace, "`}`")?;
                VariantBody::Struct(fields)
            } else if self.check(&Token::Colon) {
                // Indentation-style struct variant
                self.advance();
                self.skip_newlines();
                self.consume(Token::Indent, "indentation")?;
                let fields = self.parse_struct_fields()?;
                self.consume(Token::Dedent, "dedentation")?;
                VariantBody::Struct(fields)
            } else if self.match_token(&Token::Assign) {
                // Variant with discriminant
                let expr = self.parse_expr()?;
                VariantBody::Discriminant(Box::new(expr))
            } else {
                VariantBody::Unit
            };

            variants.push(EnumVariant {
                name: variant_name,
                body,
            });

            self.skip_newlines();
        }

        self.consume(Token::Dedent, "dedentation")?;

        let end_span = self.current_span();
        Ok(EnumDef {
            public,
            name,
            generics,
            variants,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse struct fields (for enum struct variants with indentation)
    fn parse_struct_fields(&mut self) -> ParseResult<Vec<FieldDef>> {
        let mut fields = Vec::new();

        while !self.check(&Token::Dedent) && !self.is_at_end() {
            let field_public = self.match_token(&Token::Pub);
            let field_name = self.parse_identifier()?;
            self.consume(Token::Colon, "`:`")?;
            let field_ty = self.parse_type()?;

            fields.push(FieldDef {
                public: field_public,
                name: field_name,
                ty: field_ty,
            });

            self.skip_newlines();
        }

        Ok(fields)
    }

    /// Parse struct fields within braces: `{ field: type, field2: type }`
    fn parse_brace_struct_fields(&mut self) -> ParseResult<Vec<FieldDef>> {
        let mut fields = Vec::new();

        while !self.check(&Token::RBrace) && !self.is_at_end() {
            self.skip_newlines();

            // Check for closing brace after newlines
            if self.check(&Token::RBrace) {
                break;
            }

            let field_public = self.match_token(&Token::Pub);
            let field_name = self.parse_identifier()?;
            self.consume(Token::Colon, "`:`")?;
            let field_ty = self.parse_type()?;

            fields.push(FieldDef {
                public: field_public,
                name: field_name,
                ty: field_ty,
            });

            // Allow trailing comma
            if !self.match_token(&Token::Comma) {
                break;
            }
        }

        Ok(fields)
    }

    /// Parse a trait definition
    fn parse_trait(&mut self, public: bool) -> ParseResult<TraitDef> {
        let start_span = self.current_span();
        self.consume(Token::Trait, "`trait`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Super traits (e.g., trait Show: Clone + Debug:)
        let super_traits = if self.peek_ahead_for_super_traits() {
            self.consume(Token::Colon, "`:`")?;
            self.parse_type_bounds()?
        } else {
            Vec::new()
        };

        // Body
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;

        let mut items = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            let item = self.parse_trait_item()?;
            items.push(item);
            self.skip_newlines();
        }

        self.consume(Token::Dedent, "dedentation")?;

        let end_span = self.current_span();
        Ok(TraitDef {
            public,
            name,
            generics,
            super_traits,
            items,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a trait item (method signature or type alias)
    fn parse_trait_item(&mut self) -> ParseResult<TraitItem> {
        match self.peek() {
            Some(Token::Fn) => {
                // Method signature
                self.advance();
                let name = self.parse_identifier()?;

                // Generic parameters
                let generics = if self.match_token(&Token::LBracket) {
                    let params = self.parse_generic_params()?;
                    self.consume(Token::RBracket, "`]`")?;
                    params
                } else {
                    Vec::new()
                };

                // Parameters
                self.consume(Token::LParen, "`(`")?;
                let params = self.parse_params()?;
                self.consume(Token::RParen, "`)`")?;

                // Return type
                let return_type = if self.match_token(&Token::Arrow) {
                    Some(self.parse_type()?)
                } else {
                    None
                };

                // Effects
                let effects = if self.match_token(&Token::Bang) {
                    self.parse_effects()?
                } else {
                    Vec::new()
                };

                // Where clause
                let where_clause = if self.check(&Token::Where) {
                    self.parse_where_clause()?
                } else {
                    Vec::new()
                };

                // Semicolon or newline (trait methods can end with ; or just newline)
                if self.check(&Token::Semi) {
                    self.advance();
                } else if self.check(&Token::Newline) {
                    // Newline is also valid - Python style
                } else if !self.check(&Token::Dedent) && !self.is_at_end() {
                    return Err(ParseError::unexpected_token(
                        "`;` or newline",
                        self.peek().unwrap_or(&Token::Eof),
                        self.current_span(),
                    ));
                }

                Ok(TraitItem::Method {
                    name,
                    generics,
                    params,
                    return_type,
                    effects,
                    where_clause,
                })
            }
            Some(Token::Type) => {
                // Type alias declaration
                self.advance();
                let name = self.parse_identifier()?;

                // Generic parameters
                let generics = if self.match_token(&Token::LBracket) {
                    let params = self.parse_generic_params()?;
                    self.consume(Token::RBracket, "`]`")?;
                    params
                } else {
                    Vec::new()
                };

                // Bounds
                let bounds = if self.match_token(&Token::Colon) {
                    self.parse_type_bounds()?
                } else {
                    Vec::new()
                };

                // Semicolon or newline (trait items can end with ; or just newline)
                if self.check(&Token::Semi) {
                    self.advance();
                } else if self.check(&Token::Newline) {
                    // Newline is also valid - Python style
                } else if !self.check(&Token::Dedent) && !self.is_at_end() {
                    return Err(ParseError::unexpected_token(
                        "`;` or newline",
                        self.peek().unwrap_or(&Token::Eof),
                        self.current_span(),
                    ));
                }

                Ok(TraitItem::TypeDecl {
                    name,
                    generics,
                    bounds,
                })
            }
            Some(Token::Let) => {
                // Const declaration
                self.advance();
                let name = self.parse_identifier()?;
                self.consume(Token::Colon, "`:`")?;
                let ty = self.parse_type()?;

                // Semicolon or newline (trait items can end with ; or just newline)
                if self.check(&Token::Semi) {
                    self.advance();
                } else if self.check(&Token::Newline) {
                    // Newline is also valid - Python style
                } else if !self.check(&Token::Dedent) && !self.is_at_end() {
                    return Err(ParseError::unexpected_token(
                        "`;` or newline",
                        self.peek().unwrap_or(&Token::Eof),
                        self.current_span(),
                    ));
                }

                Ok(TraitItem::ConstDecl { name, ty })
            }
            Some(token) => Err(ParseError::unexpected_token(
                "trait item",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof(
                "trait item",
                self.current_span(),
            )),
        }
    }

    /// Parse an impl block
    fn parse_impl(&mut self) -> ParseResult<ImplDef> {
        let start_span = self.current_span();
        self.consume(Token::Impl, "`impl`")?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Check for trait impl: `impl Trait for Type`
        let trait_path = if self.peek_ahead_for_for() {
            let path = self.parse_path()?;
            self.consume(Token::For, "`for`")?;
            Some(path)
        } else {
            None
        };

        // Type being implemented
        let ty = self.parse_type()?;

        // Where clause
        let where_clause = if self.check(&Token::Where) {
            self.parse_where_clause()?
        } else {
            Vec::new()
        };

        // Body
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;

        let mut items = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            let item = self.parse_impl_item()?;
            items.push(item);
            self.skip_newlines();
        }

        self.consume(Token::Dedent, "dedentation")?;

        let end_span = self.current_span();
        Ok(ImplDef {
            generics,
            trait_path,
            ty,
            where_clause,
            items,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Peek ahead to check if there's a `for` keyword (for trait impl detection)
    fn peek_ahead_for_for(&self) -> bool {
        let mut pos = self.position;
        while pos < self.tokens.len() {
            match &self.tokens[pos].token {
                Token::For => return true,
                Token::Colon | Token::LBrace | Token::Where => return false,
                _ => pos += 1,
            }
        }
        false
    }

    /// Peek ahead to check if there's a second colon (for super traits detection)
    fn peek_ahead_for_super_traits(&self) -> bool {
        let mut pos = self.position;
        let mut found_first_colon = false;
        while pos < self.tokens.len() {
            match &self.tokens[pos].token {
                Token::Colon => {
                    if found_first_colon {
                        return true; // Found second colon, so first was for super traits
                    }
                    found_first_colon = true;
                }
                Token::Newline | Token::Indent | Token::Eof => return false,
                _ => {}
            }
            pos += 1;
        }
        false
    }

    /// Parse an impl item
    fn parse_impl_item(&mut self) -> ParseResult<ImplItem> {
        match self.peek() {
            Some(Token::Fn) => {
                let func = self.parse_function(false)?;
                Ok(ImplItem::Method(func))
            }
            Some(Token::Async) => {
                // async fn in impl block
                self.advance(); // consume async
                let mut func = self.parse_function(false)?;
                // Mark function as async by adding async effect
                func.effects
                    .push(Type::Path(Path::single(Ident::new("async", func.span))));
                Ok(ImplItem::Method(func))
            }
            Some(Token::Type) => {
                // Type alias in impl block: `type Item = int;`
                let type_alias = self.parse_type_alias(false)?;
                Ok(ImplItem::TypeAlias(type_alias))
            }
            Some(Token::Let) => {
                self.advance();
                let name = self.parse_identifier()?;
                self.consume(Token::Colon, "`:`")?;
                let ty = self.parse_type()?;
                self.consume(Token::Assign, "`=`")?;
                let value = Box::new(self.parse_expr()?);

                Ok(ImplItem::Const { name, ty, value })
            }
            Some(token) => Err(ParseError::unexpected_token(
                "impl item",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof("impl item", self.current_span())),
        }
    }

    /// Parse a type alias
    fn parse_type_alias(&mut self, public: bool) -> ParseResult<TypeAlias> {
        let start_span = self.current_span();
        self.consume(Token::Type, "`type`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        self.consume(Token::Assign, "`=`")?;
        let ty = self.parse_type()?;

        let end_span = self.current_span();
        Ok(TypeAlias {
            public,
            name,
            generics,
            ty,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a const definition
    fn parse_const_def(&mut self, public: bool) -> ParseResult<ConstDef> {
        let start_span = self.current_span();
        // Accept either `const` or `let` for const definitions
        if self.check(&Token::Const) {
            self.advance();
        } else {
            self.consume(Token::Let, "`let` or `const`")?;
        }

        let name = self.parse_identifier()?;
        self.consume(Token::Colon, "`:`")?;
        let ty = self.parse_type()?;
        self.consume(Token::Assign, "`=`")?;
        let value = Box::new(self.parse_expr()?);

        let end_span = self.current_span();
        Ok(ConstDef {
            public,
            name,
            ty,
            value,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse an effect definition
    fn parse_effect_def(&mut self, public: bool) -> ParseResult<EffectDef> {
        let start_span = self.current_span();
        self.consume(Token::Effect, "`effect`")?;

        let name = self.parse_identifier()?;

        // Generic parameters
        let generics = if self.match_token(&Token::LBracket) {
            let params = self.parse_generic_params()?;
            self.consume(Token::RBracket, "`]`")?;
            params
        } else {
            Vec::new()
        };

        // Body
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;

        let mut operations = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            operations.push(self.parse_operation_def()?);
            self.skip_newlines();
        }

        self.consume(Token::Dedent, "dedentation")?;

        let end_span = self.current_span();
        Ok(EffectDef {
            public,
            name,
            generics,
            operations,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse an operation definition within an effect
    fn parse_operation_def(&mut self) -> ParseResult<OperationDef> {
        let start_span = self.current_span();
        let name = self.parse_identifier()?;

        // Parameters
        self.consume(Token::LParen, "`(`")?;
        let params = self.parse_params()?;
        self.consume(Token::RParen, "`)`")?;

        // Optional return type
        let return_type = if self.match_token(&Token::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };

        let end_span = self.current_span();
        Ok(OperationDef {
            name,
            params,
            return_type,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a statement
    #[allow(dead_code)]
    fn parse_stmt(&mut self) -> ParseResult<Stmt> {
        match self.peek() {
            Some(Token::Let) => self.parse_let_stmt(),
            Some(Token::Return) => self.parse_return_stmt(),
            Some(Token::Break) => self.parse_break_stmt(),
            Some(Token::Continue) => self.parse_continue_stmt(),
            _ => {
                // Try to parse as assignment first
                let expr = self.parse_expr()?;

                // Check if this is an assignment
                if let Some(op) = self.try_parse_assign_op() {
                    let value = self.parse_expr()?;
                    Ok(Stmt::Assign {
                        target: Box::new(expr),
                        op,
                        value: Box::new(value),
                    })
                } else {
                    Ok(Stmt::Expr(Box::new(expr)))
                }
            }
        }
    }

    /// Try to parse an assignment operator
    fn try_parse_assign_op(&mut self) -> Option<AssignOp> {
        let op = match self.peek() {
            Some(Token::Assign) => Some(AssignOp::Assign),
            Some(Token::PlusAssign) => Some(AssignOp::AddAssign),
            Some(Token::MinusAssign) => Some(AssignOp::SubAssign),
            Some(Token::StarAssign) => Some(AssignOp::MulAssign),
            Some(Token::SlashAssign) => Some(AssignOp::DivAssign),
            Some(Token::PercentAssign) => Some(AssignOp::ModAssign),
            Some(Token::AndAssign) => Some(AssignOp::BitAndAssign),
            Some(Token::OrAssign) => Some(AssignOp::BitOrAssign),
            Some(Token::XorAssign) => Some(AssignOp::BitXorAssign),
            Some(Token::ShlAssign) => Some(AssignOp::ShlAssign),
            Some(Token::ShrAssign) => Some(AssignOp::ShrAssign),
            _ => None,
        };

        if op.is_some() {
            self.advance();
        }

        op
    }

    /// Parse a let statement
    #[allow(dead_code)]
    fn parse_let_stmt(&mut self) -> ParseResult<Stmt> {
        self.consume(Token::Let, "`let`")?;

        let pattern = self.parse_pattern()?;

        // Optional type annotation
        let ty = if self.match_token(&Token::Colon) {
            Some(self.parse_type()?)
        } else {
            None
        };

        self.consume(Token::Assign, "`=`")?;
        let value = Box::new(self.parse_expr()?);

        Ok(Stmt::Let { pattern, ty, value })
    }

    /// Parse a return statement
    #[allow(dead_code)]
    fn parse_return_stmt(&mut self) -> ParseResult<Stmt> {
        self.consume(Token::Return, "`return`")?;

        // Check if there's a value to return
        let value = if self.is_at_end() || self.check(&Token::Newline) || self.check(&Token::Dedent)
        {
            None
        } else {
            Some(Box::new(self.parse_expr()?))
        };

        Ok(Stmt::Return(value))
    }

    /// Parse a break statement
    #[allow(dead_code)]
    fn parse_break_stmt(&mut self) -> ParseResult<Stmt> {
        self.consume(Token::Break, "`break`")?;

        // Optional label
        let label = if let Some(Token::Label(name)) = self.peek() {
            let name = name.clone();
            let span = self.current_span();
            self.advance();
            Some(Ident::new(name, span))
        } else {
            None
        };

        // Optional value
        let value = if self.is_at_end() || self.check(&Token::Newline) || self.check(&Token::Dedent)
        {
            None
        } else {
            Some(Box::new(self.parse_expr()?))
        };

        Ok(Stmt::Break { label, value })
    }

    /// Parse a continue statement
    #[allow(dead_code)]
    fn parse_continue_stmt(&mut self) -> ParseResult<Stmt> {
        self.consume(Token::Continue, "`continue`")?;

        // Optional label
        let label = if let Some(Token::Label(name)) = self.peek() {
            let name = name.clone();
            let span = self.current_span();
            self.advance();
            Some(Ident::new(name, span))
        } else {
            None
        };

        Ok(Stmt::Continue { label })
    }

    /// Parse an expression
    pub fn parse_expr(&mut self) -> ParseResult<Expr> {
        self.parse_expr_with_precedence(0)
    }

    /// Parse expression with minimum precedence (precedence climbing)
    fn parse_expr_with_precedence(&mut self, min_prec: u8) -> ParseResult<Expr> {
        let mut left = self.parse_prefix()?;

        loop {
            // Check for infix operator
            let (op, prec, right_assoc) = match self.peek() {
                Some(Token::Dot) => {
                    self.advance();

                    // Check for .await syntax
                    if self.check(&Token::Await) {
                        self.advance();
                        left = Expr::Await(Box::new(left));
                        continue;
                    }

                    // Field access or method call
                    let field = self.parse_identifier()?;

                    // Check if it's a method call
                    if self.match_token(&Token::LParen) {
                        let args = self.parse_arg_list()?;
                        self.consume(Token::RParen, "`)`")?;
                        left = Expr::MethodCall {
                            receiver: Box::new(left),
                            method: field,
                            args,
                        };
                    } else {
                        left = Expr::FieldAccess {
                            object: Box::new(left),
                            field,
                        };
                    }
                    continue;
                }
                Some(Token::LBracket) => {
                    self.advance();
                    let index = Box::new(self.parse_expr()?);
                    self.consume(Token::RBracket, "`]`")?;
                    left = Expr::Index {
                        object: Box::new(left),
                        index,
                    };
                    continue;
                }
                Some(Token::LParen) => {
                    self.advance();
                    let args = self.parse_arg_list()?;
                    self.consume(Token::RParen, "`)`")?;
                    left = Expr::Call {
                        func: Box::new(left),
                        args,
                    };
                    continue;
                }
                Some(Token::Question) => {
                    self.advance();
                    left = Expr::Try(Box::new(left));
                    continue;
                }
                Some(Token::Await) => {
                    self.advance();
                    left = Expr::Await(Box::new(left));
                    continue;
                }
                Some(Token::Power) => (BinaryOp::Pow, 14, true),
                Some(Token::Star) => (BinaryOp::Mul, 13, false),
                Some(Token::Slash) => (BinaryOp::Div, 13, false),
                Some(Token::Percent) => (BinaryOp::Mod, 13, false),
                Some(Token::Plus) => (BinaryOp::Add, 12, false),
                Some(Token::Minus) => (BinaryOp::Sub, 12, false),
                Some(Token::Shl) => (BinaryOp::Shl, 11, false),
                Some(Token::Shr) => (BinaryOp::Shr, 11, false),
                Some(Token::AndBit) => (BinaryOp::BitAnd, 10, false),
                Some(Token::Xor) => (BinaryOp::BitXor, 9, false),
                Some(Token::OrBit) => (BinaryOp::BitOr, 8, false),
                Some(Token::Eq) => (BinaryOp::Eq, 7, false),
                Some(Token::Ne) => (BinaryOp::Ne, 7, false),
                Some(Token::Lt) => (BinaryOp::Lt, 7, false),
                Some(Token::Gt) => (BinaryOp::Gt, 7, false),
                Some(Token::Le) => (BinaryOp::Le, 7, false),
                Some(Token::Ge) => (BinaryOp::Ge, 7, false),
                Some(Token::And) => (BinaryOp::And, 6, false),
                Some(Token::Or) => (BinaryOp::Or, 5, false),
                Some(Token::DotDot) => (BinaryOp::Range, 4, false),
                Some(Token::DotDotDot) => (BinaryOp::RangeInclusive, 4, false),
                _ => break,
            };

            if prec < min_prec {
                break;
            }

            self.advance();

            let next_min_prec = if right_assoc { prec } else { prec + 1 };
            let right = self.parse_expr_with_precedence(next_min_prec)?;

            left = Expr::Binary {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }

        Ok(left)
    }

    /// Parse a prefix expression
    fn parse_prefix(&mut self) -> ParseResult<Expr> {
        match self.peek() {
            Some(Token::Not) => {
                self.advance();
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                Ok(Expr::Unary {
                    op: UnaryOp::Not,
                    expr,
                })
            }
            Some(Token::Minus) => {
                self.advance();
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                Ok(Expr::Unary {
                    op: UnaryOp::Neg,
                    expr,
                })
            }
            Some(Token::NotBit) => {
                self.advance();
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                Ok(Expr::Unary {
                    op: UnaryOp::BitNot,
                    expr,
                })
            }
            Some(Token::Star) => {
                self.advance();
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                Ok(Expr::Unary {
                    op: UnaryOp::Deref,
                    expr,
                })
            }
            Some(Token::AndBit) => {
                self.advance();
                let mutable = self.match_token(&Token::Mut);
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                let op = if mutable {
                    UnaryOp::RefMut
                } else {
                    UnaryOp::Ref
                };
                Ok(Expr::Unary { op, expr })
            }
            Some(Token::If) => self.parse_if_expr(),
            Some(Token::Match) => self.parse_match_expr(),
            Some(Token::While) => self.parse_while_expr(None),
            Some(Token::For) => self.parse_for_expr(None),
            Some(Token::Loop) => self.parse_loop_expr(None),
            Some(Token::Label(_)) => {
                // Handle labeled loop: 'label: loop/while/for
                let label = if let Some(Token::Label(name)) = self.peek() {
                    let name = name.clone();
                    let span = self.current_span();
                    self.advance();
                    Some(Ident::new(name, span))
                } else {
                    None
                };
                self.consume(Token::Colon, "`:`")?;

                // After label:col, we expect loop/while/for
                match self.peek() {
                    Some(Token::While) => self.parse_while_expr(label),
                    Some(Token::For) => self.parse_for_expr(label),
                    Some(Token::Loop) => self.parse_loop_expr(label),
                    Some(token) => Err(ParseError::unexpected_token(
                        "`while`, `for`, or `loop`",
                        token,
                        self.current_span(),
                    )),
                    None => Err(ParseError::unexpected_eof(
                        "loop expression",
                        self.current_span(),
                    )),
                }
            }
            Some(Token::Fn) => self.parse_lambda_expr(),
            Some(Token::Async) => self.parse_async_expr(),
            Some(Token::Spawn) => self.parse_spawn_expr(),
            Some(Token::Concurrent) => self.parse_concurrent_expr(),
            Some(Token::Handle) => self.parse_handle_expr(),
            Some(Token::Raise) => self.parse_raise_expr(),
            Some(Token::Resume) => self.parse_resume_expr(),
            Some(Token::Await) => {
                self.advance();
                let expr = Box::new(self.parse_expr_with_precedence(15)?);
                Ok(Expr::Await(expr))
            }
            Some(Token::Return) => {
                self.advance();
                let value = if self.is_at_end()
                    || self.check(&Token::Newline)
                    || self.check(&Token::Dedent)
                {
                    None
                } else {
                    Some(Box::new(self.parse_expr()?))
                };
                Ok(Expr::Return(value))
            }
            Some(Token::Break) => {
                self.advance();
                let label = if let Some(Token::Label(name)) = self.peek() {
                    let name = name.clone();
                    let span = self.current_span();
                    self.advance();
                    Some(Ident::new(name, span))
                } else {
                    None
                };
                let value = if self.is_at_end()
                    || self.check(&Token::Newline)
                    || self.check(&Token::Dedent)
                {
                    None
                } else {
                    Some(Box::new(self.parse_expr()?))
                };
                Ok(Expr::Break { label, value })
            }
            Some(Token::Continue) => {
                self.advance();
                let label = if let Some(Token::Label(name)) = self.peek() {
                    let name = name.clone();
                    let span = self.current_span();
                    self.advance();
                    Some(Ident::new(name, span))
                } else {
                    None
                };
                Ok(Expr::Continue { label })
            }
            Some(Token::LParen) => self.parse_tuple_expr(),
            Some(Token::LBracket) => self.parse_array_expr(),
            Some(Token::LBrace) => {
                self.advance();
                let block = self.parse_block_internal()?;
                self.consume(Token::RBrace, "`}`")?;
                Ok(Expr::Block(block))
            }
            Some(Token::Self_) => {
                let span = self.current_span();
                self.advance();
                Ok(Expr::SelfExpr(span))
            }
            Some(Token::Ident(name))
                if name == "try" && self.peek_ahead(1) == Some(&Token::Colon) =>
            {
                self.parse_try_block_expr()
            }
            _ => self.parse_primary(),
        }
    }

    /// Parse a lambda expression with pipe syntax: |x, y| expr or |x: i32| -> i32 { x }
    fn parse_lambda_expr_with_pipes(&mut self) -> ParseResult<Expr> {
        self.consume(Token::OrBit, "`|`")?;

        // Parse parameters (optional)
        let mut params = Vec::new();

        if !self.check(&Token::OrBit) {
            loop {
                let pattern = self.parse_pattern()?;
                // Check for type annotation: |x: i32|
                let ty = if self.match_token(&Token::Colon) {
                    self.parse_type()?
                } else {
                    Type::Infer
                };
                params.push(Param { pattern, ty });

                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        self.consume(Token::OrBit, "`|`")?;

        // Optional return type: |x| -> i32 { ... }
        let return_type = if self.match_token(&Token::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };

        // Optional effects: |x| -> i32 ! Effect { ... }
        let effects = if self.match_token(&Token::Bang) {
            self.parse_effects()?
        } else {
            Vec::new()
        };

        // Body can be a block { ... } or an expression
        let body = if self.check(&Token::LBrace) {
            // Block body: |x| { x + 1 }
            self.advance(); // consume {
            self.skip_newlines();
            let block = self.parse_block_internal()?;
            self.consume(Token::RBrace, "`}`")?;
            Box::new(Expr::Block(block))
        } else {
            // Expression body: |x| x + 1
            Box::new(self.parse_expr()?)
        };

        Ok(Expr::Lambda {
            params,
            return_type,
            effects,
            body,
        })
    }

    /// Parse a primary expression (literals, identifiers, paths)
    fn parse_primary(&mut self) -> ParseResult<Expr> {
        match self.peek() {
            Some(Token::Integer(s)) => {
                let val = s.parse::<i64>().unwrap_or(0);
                self.advance();
                Ok(Expr::Literal(Literal::Integer(val)))
            }
            Some(Token::Float(s)) => {
                let val = s.parse::<f64>().unwrap_or(0.0);
                self.advance();
                Ok(Expr::Literal(Literal::Float(val)))
            }
            Some(Token::String(s)) => {
                let val = s.clone();
                self.advance();
                Ok(Expr::Literal(Literal::String(val)))
            }
            Some(Token::Char(c)) => {
                let val = *c;
                self.advance();
                Ok(Expr::Literal(Literal::Char(val)))
            }
            Some(Token::Bool(b)) => {
                let val = *b;
                self.advance();
                Ok(Expr::Literal(Literal::Bool(val)))
            }
            Some(Token::True) => {
                self.advance();
                Ok(Expr::Literal(Literal::Bool(true)))
            }
            Some(Token::False) => {
                self.advance();
                Ok(Expr::Literal(Literal::Bool(false)))
            }
            Some(Token::Ident(_)) => {
                let path = self.parse_path()?;
                // Check if it's a struct literal
                if self.match_token(&Token::LBrace) {
                    self.parse_struct_literal_rest(path)
                } else {
                    Ok(Expr::Path(path))
                }
            }
            Some(Token::Chan) => {
                let span = self.current_span();
                self.advance();
                Ok(Expr::Variable(Ident::new("chan", span)))
            }
            Some(Token::Underscore) => {
                // Hole expression for hole-driven development
                let span = self.current_span();
                self.advance();
                Ok(Expr::Hole(span))
            }
            Some(Token::Unit) => {
                self.advance();
                Ok(Expr::Literal(Literal::Unit))
            }
            Some(Token::Pass) => {
                self.advance();
                Ok(Expr::Pass)
            }
            Some(Token::OrBit) => {
                // Lambda expression: |params| body
                self.parse_lambda_expr_with_pipes()
            }
            Some(token) => Err(ParseError::unexpected_token(
                "expression",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof(
                "expression",
                self.current_span(),
            )),
        }
    }

    /// Parse the rest of a struct literal after `{`
    fn parse_struct_literal_rest(&mut self, path: Path) -> ParseResult<Expr> {
        let mut fields = Vec::new();

        // Handle optional indentation after opening brace
        self.skip_newlines();
        if self.check(&Token::Indent) {
            self.advance();
        }

        if !self.check(&Token::RBrace) && !self.check(&Token::Dedent) {
            loop {
                self.skip_newlines();

                // Check for closing brace or dedent after newlines
                if self.check(&Token::RBrace) || self.check(&Token::Dedent) {
                    break;
                }

                let name = self.parse_identifier()?;
                let value = if self.match_token(&Token::Colon) {
                    Some(self.parse_expr()?)
                } else {
                    None // Shorthand: `x` means `x: x`
                };

                fields.push(FieldInit { name, value });

                self.skip_newlines();

                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        // Handle optional dedent before closing brace
        if self.check(&Token::Dedent) {
            self.advance();
        }

        self.consume(Token::RBrace, "`}`")?;

        Ok(Expr::StructLiteral { path, fields })
    }

    /// Parse a tuple expression
    fn parse_tuple_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::LParen, "`(`")?;

        // Empty tuple = unit
        if self.match_token(&Token::RParen) {
            return Ok(Expr::Literal(Literal::Unit));
        }

        let mut elements = Vec::new();
        elements.push(self.parse_expr()?);

        // Single element in parentheses is just grouping
        if self.match_token(&Token::RParen) {
            return Ok(elements.into_iter().next().unwrap());
        }

        // Multiple elements = tuple
        while self.match_token(&Token::Comma) {
            if self.check(&Token::RParen) {
                break;
            }
            elements.push(self.parse_expr()?);
        }

        self.consume(Token::RParen, "`)`")?;

        Ok(Expr::Tuple(elements))
    }

    /// Parse an array expression
    fn parse_array_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::LBracket, "`[`")?;

        let mut elements = Vec::new();

        if !self.check(&Token::RBracket) {
            loop {
                elements.push(self.parse_expr()?);
                if !self.match_token(&Token::Comma) {
                    break;
                }
                // Allow trailing comma: if next token is ], we're done
                if self.check(&Token::RBracket) {
                    break;
                }
            }
        }

        self.consume(Token::RBracket, "`]`")?;

        Ok(Expr::Array(elements))
    }

    /// Parse an if expression
    fn parse_if_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::If, "`if`")?;
        let cond = Box::new(self.parse_expr()?);

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let then_block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        let then_branch = Box::new(Expr::Block(then_block));

        // Check for elif/else
        let else_branch = if self.check(&Token::Elif) {
            Some(Box::new(self.parse_elif_chain()?))
        } else if self.match_token(&Token::Else) {
            self.consume(Token::Colon, "`:`")?;
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let else_block = self.parse_block_internal()?;
            self.skip_newlines();
            self.consume(Token::Dedent, "dedentation")?;
            Some(Box::new(Expr::Block(else_block)))
        } else {
            None
        };

        Ok(Expr::If {
            cond,
            then_branch,
            else_branch,
        })
    }

    /// Parse elif chain as nested if expressions
    fn parse_elif_chain(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Elif, "`elif`")?;
        let cond = Box::new(self.parse_expr()?);

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let then_block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        let then_branch = Box::new(Expr::Block(then_block));

        // Check for more elif/else
        let else_branch = if self.check(&Token::Elif) {
            Some(Box::new(self.parse_elif_chain()?))
        } else if self.match_token(&Token::Else) {
            self.consume(Token::Colon, "`:`")?;
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let else_block = self.parse_block_internal()?;
            self.skip_newlines();
            self.consume(Token::Dedent, "dedentation")?;
            Some(Box::new(Expr::Block(else_block)))
        } else {
            None
        };

        Ok(Expr::If {
            cond,
            then_branch,
            else_branch,
        })
    }

    /// Parse a match expression
    fn parse_match_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Match, "`match`")?;
        let expr = Box::new(self.parse_expr()?);

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;

        let mut arms = Vec::new();
        while !self.check(&Token::Dedent) && !self.is_at_end() {
            arms.push(self.parse_match_arm()?);
            self.skip_newlines();
        }

        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        Ok(Expr::Match { expr, arms })
    }

    /// Parse a match arm
    fn parse_match_arm(&mut self) -> ParseResult<MatchArm> {
        self.consume(Token::OrBit, "`|`")?;
        let pattern = self.parse_pattern()?;

        // Optional guard
        let guard = if self.match_token(&Token::If) {
            Some(Box::new(self.parse_expr()?))
        } else {
            None
        };

        // Match arm body can use `=>` or `->`
        if self.match_token(&Token::FatArrow) {
            // Block or expression body
            let body = if self.check(&Token::Indent) {
                self.advance();
                let block = self.parse_block_internal()?;
                self.consume(Token::Dedent, "dedentation")?;
                Box::new(Expr::Block(block))
            } else {
                Box::new(self.parse_expr()?)
            };

            Ok(MatchArm {
                pattern,
                guard,
                body,
            })
        } else if self.match_token(&Token::Arrow) {
            // Single expression body with `->`
            // The expression may be on the next line, or it could be an indented block
            self.skip_newlines();

            let body = if self.check(&Token::Indent) {
                // Indented block body after ->
                self.advance();
                let block = self.parse_block_internal()?;
                self.consume(Token::Dedent, "dedentation")?;
                Box::new(Expr::Block(block))
            } else {
                Box::new(self.parse_expr()?)
            };

            Ok(MatchArm {
                pattern,
                guard,
                body,
            })
        } else {
            Err(ParseError::unexpected_token(
                "`=>` or `->`",
                self.peek().unwrap_or(&Token::Eof),
                self.current_span(),
            ))
        }
    }

    /// Parse a while expression
    fn parse_while_expr(&mut self, label: Option<Ident>) -> ParseResult<Expr> {
        self.consume(Token::While, "`while`")?;
        let cond = Box::new(self.parse_expr()?);

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        Ok(Expr::While {
            label,
            cond,
            invariant: None,
            body: Box::new(Expr::Block(block)),
        })
    }

    /// Parse a for expression
    fn parse_for_expr(&mut self, label: Option<Ident>) -> ParseResult<Expr> {
        self.consume(Token::For, "`for`")?;
        let pattern = self.parse_pattern()?;
        self.consume(Token::In, "`in`")?;
        let iterable = Box::new(self.parse_expr()?);

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        Ok(Expr::For {
            label,
            pattern,
            iterable,
            invariant: None,
            body: Box::new(Expr::Block(block)),
        })
    }

    /// Parse a loop expression
    fn parse_loop_expr(&mut self, label: Option<Ident>) -> ParseResult<Expr> {
        self.consume(Token::Loop, "`loop`")?;

        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;

        Ok(Expr::Loop {
            label,
            invariant: None,
            body: Box::new(Expr::Block(block)),
        })
    }

    /// Parse a lambda expression
    fn parse_lambda_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Fn, "`fn`")?;

        // Optional parameters
        let params = if self.match_token(&Token::LParen) {
            let p = self.parse_params()?;
            self.consume(Token::RParen, "`)`")?;
            p
        } else {
            Vec::new()
        };

        // Return type
        let return_type = if self.match_token(&Token::Arrow) {
            Some(self.parse_type()?)
        } else {
            None
        };

        // Effects
        let effects = if self.match_token(&Token::Bang) {
            self.parse_effects()?
        } else {
            Vec::new()
        };

        // Body
        let body = if self.match_token(&Token::FatArrow) {
            // Expression body: `=> expr`
            Box::new(self.parse_expr()?)
        } else if self.check(&Token::Colon) {
            // Block body
            self.advance();
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let block = self.parse_block_internal()?;
            self.consume(Token::Dedent, "dedentation")?;
            Box::new(Expr::Block(block))
        } else {
            return Err(ParseError::unexpected_token(
                "`=>` or `:`",
                self.peek().unwrap_or(&Token::Eof),
                self.current_span(),
            ));
        };

        Ok(Expr::Lambda {
            params,
            return_type,
            effects,
            body,
        })
    }

    /// Parse an async expression
    fn parse_async_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Async, "`async`")?;

        if self.check(&Token::Colon) {
            // Async block
            self.advance();
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let block = self.parse_block_internal()?;
            self.consume(Token::Dedent, "dedentation")?;
            Ok(Expr::Async(block))
        } else {
            // Async expression
            let expr = Box::new(self.parse_expr_with_precedence(15)?);
            Ok(Expr::Await(expr)) // async expr is sugar for await(expr)
        }
    }

    /// Parse a `try:` expression block.
    fn parse_try_block_expr(&mut self) -> ParseResult<Expr> {
        // Consume the `try` identifier and block opener
        self.advance();
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let block = self.parse_block_internal()?;
        self.skip_newlines();
        self.consume(Token::Dedent, "dedentation")?;
        Ok(Expr::Try(Box::new(Expr::Block(block))))
    }

    /// Parse a spawn expression
    fn parse_spawn_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Spawn, "`spawn`")?;
        let expr = Box::new(self.parse_expr_with_precedence(15)?);
        Ok(Expr::Spawn(expr))
    }

    /// Parse a concurrent expression
    fn parse_concurrent_expr(&mut self) -> ParseResult<Expr> {
        self.consume(Token::Concurrent, "`concurrent`")?;
        self.consume(Token::Colon, "`:`")?;
        self.skip_newlines();
        self.consume(Token::Indent, "indentation")?;
        let block = self.parse_block_internal()?;
        self.consume(Token::Dedent, "dedentation")?;
        Ok(Expr::Concurrent(block))
    }

    /// Parse a raise expression
    fn parse_raise_expr(&mut self) -> ParseResult<Expr> {
        let start_span = self.current_span();
        self.consume(Token::Raise, "`raise`")?;

        // Check for effect::operation syntax
        let mut effect = None;
        let operation;

        // Try to parse a path (could be just operation or effect::operation)
        let first_ident = self.parse_identifier()?;

        if self.match_token(&Token::ColonColon) {
            // This is effect::operation syntax
            effect = Some(Path::single(first_ident));
            operation = self.parse_identifier()?;
        } else {
            // Just operation name
            operation = first_ident;
        }

        // Parse arguments if present
        let args = if self.check(&Token::LParen) {
            self.advance();
            let args = self.parse_arg_list()?;
            self.consume(Token::RParen, "`)`")?;
            args
        } else {
            Vec::new()
        };

        let end_span = self.current_span();
        Ok(Expr::Raise(RaiseExpr {
            effect,
            operation,
            args,
            span: Span::new(start_span.start, end_span.end),
        }))
    }

    /// Parse a handle expression
    fn parse_handle_expr(&mut self) -> ParseResult<Expr> {
        let start_span = self.current_span();
        self.consume(Token::Handle, "`handle`")?;

        // Optional 'with' keyword for more natural syntax: handle with { ... }
        self.match_token(&Token::With);

        // Body of the handled expression
        let body = if self.check(&Token::Colon) {
            // Block body
            self.advance();
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;
            let block = self.parse_block_internal()?;
            self.consume(Token::Dedent, "dedentation")?;
            Box::new(Expr::Block(block))
        } else if self.check(&Token::LBrace) {
            // Brace-delimited body
            self.advance();
            let block = self.parse_block_internal()?;
            self.consume(Token::RBrace, "`}`")?;
            Box::new(Expr::Block(block))
        } else {
            // Single expression
            Box::new(self.parse_expr()?)
        };

        // Parse handlers
        let handlers = self.parse_handler_arms()?;

        let end_span = self.current_span();
        Ok(Expr::Handle(HandleExpr {
            body,
            handlers,
            span: Span::new(start_span.start, end_span.end),
        }))
    }

    /// Parse handler arms for effect handling
    fn parse_handler_arms(&mut self) -> ParseResult<Vec<HandlerArm>> {
        let mut handlers = Vec::new();

        // Handlers can be introduced with 'with' or just start with the arms
        if self.check(&Token::With) {
            self.advance();
        }

        if self.check(&Token::Colon) {
            self.advance();
            self.skip_newlines();
            self.consume(Token::Indent, "indentation")?;

            while !self.check(&Token::Dedent) && !self.is_at_end() {
                handlers.push(self.parse_handler_arm()?);
                self.skip_newlines();
            }

            self.consume(Token::Dedent, "dedentation")?;
        } else if self.check(&Token::LBrace) {
            self.advance();
            self.skip_newlines();

            while !self.check(&Token::RBrace) && !self.is_at_end() {
                handlers.push(self.parse_handler_arm()?);
                self.skip_newlines();
            }

            self.consume(Token::RBrace, "`}`")?;
        }

        Ok(handlers)
    }

    /// Parse a single handler arm
    fn parse_handler_arm(&mut self) -> ParseResult<HandlerArm> {
        let start_span = self.current_span();

        // Handler arm syntax: operation(params) -> body or operation(params) => body
        // or with pattern matching: | Pattern => body

        if self.check(&Token::OrBit) {
            // Pattern-based handler arm: | Pattern => body
            self.advance(); // consume |
            let pattern = self.parse_pattern()?;

            // Expect => or ->
            let body = if self.match_token(&Token::FatArrow) {
                if self.check(&Token::Indent) {
                    self.advance();
                    let block = self.parse_block_internal()?;
                    self.consume(Token::Dedent, "dedentation")?;
                    Box::new(Expr::Block(block))
                } else {
                    Box::new(self.parse_expr()?)
                }
            } else if self.match_token(&Token::Arrow) {
                self.skip_newlines();
                if self.check(&Token::Indent) {
                    self.advance();
                    let block = self.parse_block_internal()?;
                    self.consume(Token::Dedent, "dedentation")?;
                    Box::new(Expr::Block(block))
                } else {
                    Box::new(self.parse_expr()?)
                }
            } else {
                return Err(ParseError::unexpected_token(
                    "`=>` or `->`",
                    self.peek().unwrap_or(&Token::Eof),
                    self.current_span(),
                ));
            };

            let end_span = self.current_span();
            Ok(HandlerArm {
                operation: Ident::new("_", pattern.span()), // Placeholder for pattern-based handlers
                params: vec![pattern],
                resume_name: None,
                body: *body,
                span: Span::new(start_span.start, end_span.end),
            })
        } else {
            // Operation-based handler arm: operation(params) [as resume_name] => body
            let operation = self.parse_identifier()?;

            // Parse parameters
            let params = if self.check(&Token::LParen) {
                self.advance();
                let mut params = Vec::new();
                if !self.check(&Token::RParen) {
                    loop {
                        params.push(self.parse_pattern()?);
                        if !self.match_token(&Token::Comma) {
                            break;
                        }
                    }
                }
                self.consume(Token::RParen, "`)`")?;
                params
            } else {
                Vec::new()
            };

            // Optional resume name: operation(x) as resume => body
            let resume_name = if self.match_token(&Token::As) {
                Some(self.parse_identifier()?)
            } else {
                None
            };

            // Expect => or ->
            let body = if self.match_token(&Token::FatArrow) {
                if self.check(&Token::Indent) {
                    self.advance();
                    let block = self.parse_block_internal()?;
                    self.consume(Token::Dedent, "dedentation")?;
                    Box::new(Expr::Block(block))
                } else {
                    Box::new(self.parse_expr()?)
                }
            } else if self.match_token(&Token::Arrow) {
                self.skip_newlines();
                if self.check(&Token::Indent) {
                    self.advance();
                    let block = self.parse_block_internal()?;
                    self.consume(Token::Dedent, "dedentation")?;
                    Box::new(Expr::Block(block))
                } else {
                    Box::new(self.parse_expr()?)
                }
            } else {
                return Err(ParseError::unexpected_token(
                    "`=>` or `->`",
                    self.peek().unwrap_or(&Token::Eof),
                    self.current_span(),
                ));
            };

            let end_span = self.current_span();
            Ok(HandlerArm {
                operation,
                params,
                resume_name,
                body: *body,
                span: Span::new(start_span.start, end_span.end),
            })
        }
    }

    /// Parse a resume expression
    fn parse_resume_expr(&mut self) -> ParseResult<Expr> {
        let start_span = self.current_span();
        self.consume(Token::Resume, "`resume`")?;

        // Optional value to resume with
        let value = if self.is_at_end()
            || self.check(&Token::Newline)
            || self.check(&Token::Dedent)
            || self.check(&Token::RBrace)
        {
            None
        } else {
            Some(Box::new(self.parse_expr()?))
        };

        let end_span = self.current_span();
        Ok(Expr::Resume(ResumeExpr {
            value,
            span: Span::new(start_span.start, end_span.end),
        }))
    }

    /// Parse a block (internal, assumes indent already consumed)
    fn parse_block_internal(&mut self) -> ParseResult<Block> {
        let start_span = self.current_span();
        let mut stmts = Vec::new();

        self.skip_newlines();

        while !self.check(&Token::Dedent) && !self.check(&Token::RBrace) && !self.is_at_end() {
            // Check for let statement first
            if self.check(&Token::Let) {
                let stmt = self.parse_let_stmt()?;
                stmts.push(stmt);
                self.skip_newlines();
                continue;
            }

            // Check for return/break/continue statements
            if self.check(&Token::Return) {
                let stmt = self.parse_return_stmt()?;
                stmts.push(stmt);
                self.skip_newlines();
                // These are always terminal, so check if we're at end of block
                if self.check(&Token::Dedent) || self.check(&Token::RBrace) || self.is_at_end() {
                    let end_span = self.current_span();
                    return Ok(Block {
                        stmts,
                        expr: None,
                        span: Span::new(start_span.start, end_span.end),
                    });
                }
                continue;
            }

            if self.check(&Token::Break) {
                let stmt = self.parse_break_stmt()?;
                stmts.push(stmt);
                self.skip_newlines();
                if self.check(&Token::Dedent) || self.check(&Token::RBrace) || self.is_at_end() {
                    let end_span = self.current_span();
                    return Ok(Block {
                        stmts,
                        expr: None,
                        span: Span::new(start_span.start, end_span.end),
                    });
                }
                continue;
            }

            if self.check(&Token::Continue) {
                let stmt = self.parse_continue_stmt()?;
                stmts.push(stmt);
                self.skip_newlines();
                if self.check(&Token::Dedent) || self.check(&Token::RBrace) || self.is_at_end() {
                    let end_span = self.current_span();
                    return Ok(Block {
                        stmts,
                        expr: None,
                        span: Span::new(start_span.start, end_span.end),
                    });
                }
                continue;
            }

            // Check if this is the final expression (no assignment, etc.)
            let expr = self.parse_expr()?;

            // Check for assignment first
            if let Some(op) = self.try_parse_assign_op() {
                let value = self.parse_expr()?;
                stmts.push(Stmt::Assign {
                    target: Box::new(expr),
                    op,
                    value: Box::new(value),
                });
                self.skip_newlines();
                continue;
            }

            // If it's followed by newline/dedent/rbrace, treat as statement
            // (final expression should only be used for implicit return values)
            if self.check(&Token::Newline)
                || self.check(&Token::Dedent)
                || self.check(&Token::RBrace)
            {
                // Consume newline if present so caller sees dedent
                self.skip_newlines();

                // Check if we're at the end of the block
                if self.check(&Token::Dedent) || self.check(&Token::RBrace) || self.is_at_end() {
                    // At end of block - could be final expr or statement
                    // For now, treat as statement to match test expectations
                    stmts.push(Stmt::Expr(Box::new(expr)));
                    let end_span = self.current_span();
                    return Ok(Block {
                        stmts,
                        expr: None,
                        span: Span::new(start_span.start, end_span.end),
                    });
                } else {
                    // More items follow, treat as statement
                    stmts.push(Stmt::Expr(Box::new(expr)));
                    continue;
                }
            }

            // Otherwise it's a statement
            stmts.push(Stmt::Expr(Box::new(expr)));

            self.skip_newlines();
        }

        let end_span = self.current_span();
        Ok(Block {
            stmts,
            expr: None,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse a pattern
    fn parse_pattern(&mut self) -> ParseResult<Pattern> {
        // Check for mut/ref prefixes
        if self.match_token(&Token::Mut) {
            let inner = self.parse_pattern()?;
            return Ok(Pattern::Mut(Box::new(inner)));
        }

        // Check for ref keyword (used as identifier since 'ref' is not a keyword)
        if let Some(Token::Ident(name)) = self.peek() {
            if name == "ref" {
                self.advance();
                let mutable = self.match_token(&Token::Mut);
                let inner = self.parse_pattern()?;
                return Ok(Pattern::Ref {
                    mutable,
                    pattern: Box::new(inner),
                });
            }
        }

        match self.peek() {
            Some(Token::Underscore) => {
                let span = self.current_span();
                self.advance();
                Ok(Pattern::Wildcard(span))
            }
            Some(Token::Ident(_)) => {
                // Could be identifier, struct pattern, or enum pattern
                let path = self.parse_path()?;

                // Check for struct pattern
                if self.match_token(&Token::LBrace) {
                    let mut fields = Vec::new();
                    let mut rest = false;

                    if !self.check(&Token::RBrace) {
                        loop {
                            // Check for rest pattern
                            if self.match_token(&Token::DotDot) {
                                rest = true;
                                break;
                            }

                            let name = self.parse_identifier()?;
                            let pattern = if self.match_token(&Token::Colon) {
                                Some(self.parse_pattern()?)
                            } else {
                                None
                            };

                            fields.push(FieldPattern { name, pattern });

                            if !self.match_token(&Token::Comma) {
                                break;
                            }
                        }
                    }

                    self.consume(Token::RBrace, "`}`")?;
                    Ok(Pattern::Struct { path, fields, rest })
                }
                // Check for tuple struct pattern
                else if self.match_token(&Token::LParen) {
                    let mut patterns = Vec::new();
                    if !self.check(&Token::RParen) {
                        loop {
                            patterns.push(self.parse_pattern()?);
                            if !self.match_token(&Token::Comma) {
                                break;
                            }
                        }
                    }
                    self.consume(Token::RParen, "`)`")?;
                    Ok(Pattern::Tuple(patterns))
                }
                // Check for enum variant pattern with ::
                else if self.match_token(&Token::ColonColon) {
                    let variant = self.parse_identifier()?;
                    let inner = if self.match_token(&Token::LParen) {
                        let p = Some(Box::new(self.parse_pattern()?));
                        self.consume(Token::RParen, "`)`")?;
                        p
                    } else {
                        None
                    };
                    Ok(Pattern::Enum {
                        path,
                        variant,
                        inner,
                    })
                }
                // Simple identifier pattern
                else {
                    Ok(Pattern::Ident {
                        mutable: false,
                        name: path.segments.into_iter().next().unwrap(),
                    })
                }
            }
            Some(Token::Integer(_))
            | Some(Token::Float(_))
            | Some(Token::String(_))
            | Some(Token::Char(_))
            | Some(Token::Bool(_))
            | Some(Token::True)
            | Some(Token::False) => {
                let lit = self.parse_literal()?;
                Ok(Pattern::Literal(lit))
            }
            Some(Token::LParen) => {
                self.advance();
                let mut patterns = Vec::new();
                if !self.check(&Token::RParen) {
                    loop {
                        patterns.push(self.parse_pattern()?);
                        if !self.match_token(&Token::Comma) {
                            break;
                        }
                    }
                }
                self.consume(Token::RParen, "`)`")?;
                Ok(Pattern::Tuple(patterns))
            }
            Some(Token::LBracket) => {
                self.advance();
                let mut patterns = Vec::new();
                if !self.check(&Token::RBracket) {
                    loop {
                        patterns.push(self.parse_pattern()?);
                        if !self.match_token(&Token::Comma) {
                            break;
                        }
                    }
                }
                self.consume(Token::RBracket, "`]`")?;
                Ok(Pattern::Array(patterns))
            }
            Some(Token::DotDot) => {
                self.advance();
                let rest_name = if let Some(Token::Ident(_)) = self.peek() {
                    Some(self.parse_identifier()?)
                } else {
                    None
                };
                Ok(Pattern::Rest(rest_name))
            }
            Some(token) => Err(ParseError::unexpected_token(
                "pattern",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof("pattern", self.current_span())),
        }
    }

    /// Parse a literal
    fn parse_literal(&mut self) -> ParseResult<Literal> {
        match self.peek() {
            Some(Token::Integer(s)) => {
                let val = s.parse::<i64>().unwrap_or(0);
                self.advance();
                Ok(Literal::Integer(val))
            }
            Some(Token::Float(s)) => {
                let val = s.parse::<f64>().unwrap_or(0.0);
                self.advance();
                Ok(Literal::Float(val))
            }
            Some(Token::String(s)) => {
                let val = s.clone();
                self.advance();
                Ok(Literal::String(val))
            }
            Some(Token::Char(c)) => {
                let val = *c;
                self.advance();
                Ok(Literal::Char(val))
            }
            Some(Token::Bool(b)) => {
                let val = *b;
                self.advance();
                Ok(Literal::Bool(val))
            }
            Some(Token::True) => {
                self.advance();
                Ok(Literal::Bool(true))
            }
            Some(Token::False) => {
                self.advance();
                Ok(Literal::Bool(false))
            }
            Some(token) => Err(ParseError::unexpected_token(
                "literal",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof("literal", self.current_span())),
        }
    }

    /// Parse a type
    fn parse_type(&mut self) -> ParseResult<Type> {
        match self.peek() {
            Some(Token::AndBit) => {
                self.advance();
                let mutable = self.match_token(&Token::Mut);
                let inner = Box::new(self.parse_type()?);
                Ok(Type::Reference { mutable, inner })
            }
            Some(Token::Fn) => {
                self.advance();
                self.consume(Token::LParen, "`(`")?;
                let params = self.parse_type_list()?;
                self.consume(Token::RParen, "`)`")?;

                let return_type = if self.match_token(&Token::Arrow) {
                    Some(Box::new(self.parse_type()?))
                } else {
                    None
                };

                let effects = if self.match_token(&Token::Bang) {
                    self.parse_effects()?
                } else {
                    Vec::new()
                };

                Ok(Type::Function {
                    params,
                    return_type,
                    effects,
                })
            }
            Some(Token::Chan) => {
                self.advance();
                self.consume(Token::LBracket, "`[`")?;
                let inner = Box::new(self.parse_type()?);
                self.consume(Token::RBracket, "`]`")?;
                Ok(Type::Channel(inner))
            }
            Some(Token::Async) => {
                self.advance();
                let inner = Box::new(self.parse_type()?);
                Ok(Type::Async(inner))
            }
            Some(Token::LParen) => {
                self.advance();
                // Empty tuple = unit
                if self.match_token(&Token::RParen) {
                    return Ok(Type::Path(Path::single(Ident::new(
                        "unit",
                        self.current_span(),
                    ))));
                }

                let mut types = Vec::new();
                types.push(self.parse_type()?);

                // Single type in parens is just grouping
                if self.match_token(&Token::RParen) {
                    return Ok(types.into_iter().next().unwrap());
                }

                // Multiple types = tuple
                while self.match_token(&Token::Comma) {
                    if self.check(&Token::RParen) {
                        break;
                    }
                    types.push(self.parse_type()?);
                }

                self.consume(Token::RParen, "`)`")?;
                Ok(Type::Tuple(types))
            }
            Some(Token::LBracket) => {
                self.advance();
                let inner = Box::new(self.parse_type()?);

                // Check for array type `[T; n]` or slice `[T]`
                let size = if self.match_token(&Token::Semi) {
                    Some(Box::new(self.parse_expr()?))
                } else {
                    None
                };

                self.consume(Token::RBracket, "`]`")?;
                Ok(Type::Array(inner, size))
            }
            Some(Token::Underscore) => {
                self.advance();
                Ok(Type::Infer)
            }
            Some(Token::Unit) => {
                self.advance();
                Ok(Type::Path(Path::single(Ident::new(
                    "unit",
                    self.current_span(),
                ))))
            }
            Some(Token::Self_) | Some(Token::Ident(_)) => {
                let mut path = self.parse_path()?;

                // Check for associated type access: Type.Item (e.g., Self.Item)
                while self.match_token(&Token::Dot) {
                    let assoc = self.parse_identifier()?;
                    // Extend the path with the associated type
                    path.segments.push(assoc);
                    path.span = Span::new(path.span.start, self.current_span().end);
                }

                // Check for generic type
                if self.match_token(&Token::LBracket) {
                    let mut args = Vec::new();
                    if !self.check(&Token::RBracket) {
                        loop {
                            args.push(self.parse_type()?);
                            if !self.match_token(&Token::Comma) {
                                break;
                            }
                        }
                    }
                    self.consume(Token::RBracket, "`]`")?;
                    Ok(Type::Generic(Box::new(Type::Path(path)), args))
                } else {
                    Ok(Type::Path(path))
                }
            }
            Some(token) => Err(ParseError::unexpected_token(
                "type",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof("type", self.current_span())),
        }
    }

    /// Parse a comma-separated list of types
    fn parse_type_list(&mut self) -> ParseResult<Vec<Type>> {
        let mut types = Vec::new();

        if !self.check(&Token::RParen) {
            loop {
                types.push(self.parse_type()?);
                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        Ok(types)
    }

    /// Parse tuple types for enum variants
    fn parse_tuple_types(&mut self) -> ParseResult<Vec<Type>> {
        self.parse_type_list()
    }

    /// Parse a path (e.g., `std::collections::Vec`)
    fn parse_path(&mut self) -> ParseResult<Path> {
        let start_span = self.current_span();
        let mut segments = Vec::new();

        loop {
            segments.push(self.parse_identifier()?);

            if !self.match_token(&Token::ColonColon) {
                break;
            }
        }

        let end_span = self.current_span();
        Ok(Path::new(
            segments,
            Span::new(start_span.start, end_span.end),
        ))
    }

    /// Parse an identifier (or certain keywords that can be used as identifiers)
    fn parse_identifier(&mut self) -> ParseResult<Ident> {
        match self.peek() {
            Some(Token::Ident(name)) => {
                let span = self.current_span();
                let name = name.clone();
                self.advance();
                Ok(Ident::new(name, span))
            }
            Some(Token::Self_) => {
                let span = self.current_span();
                self.advance();
                Ok(Ident::new("Self", span))
            }
            // Allow certain keywords to be used as identifiers
            Some(Token::From) => {
                let span = self.current_span();
                self.advance();
                Ok(Ident::new("from", span))
            }
            Some(token) => Err(ParseError::unexpected_token(
                "identifier",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof(
                "identifier",
                self.current_span(),
            )),
        }
    }

    /// Parse an argument list
    fn parse_arg_list(&mut self) -> ParseResult<Vec<Expr>> {
        let mut args = Vec::new();

        if !self.check(&Token::RParen) {
            loop {
                args.push(self.parse_expr()?);
                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        Ok(args)
    }

    // Helper methods

    fn peek(&self) -> Option<&Token> {
        self.tokens.get(self.position).map(|t| &t.token)
    }

    #[allow(dead_code)]
    fn peek_ahead(&self, offset: usize) -> Option<&Token> {
        self.tokens.get(self.position + offset).map(|t| &t.token)
    }

    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.position += 1;
        }
        &self.tokens[self.position - 1].token
    }

    fn is_at_end(&self) -> bool {
        matches!(self.peek(), Some(Token::Eof) | None)
    }

    fn check(&self, token: &Token) -> bool {
        self.peek() == Some(token)
    }

    fn match_token(&mut self, token: &Token) -> bool {
        if self.check(token) {
            self.advance();
            true
        } else {
            false
        }
    }

    fn consume(&mut self, expected: Token, description: &str) -> ParseResult<()> {
        if self.check(&expected) {
            self.advance();
            Ok(())
        } else {
            Err(ParseError::unexpected_token(
                description,
                self.peek().unwrap_or(&Token::Eof),
                self.current_span(),
            ))
        }
    }

    fn current_span(&self) -> Span {
        self.tokens
            .get(self.position)
            .map(|t| t.span)
            .unwrap_or_else(|| {
                self.tokens
                    .last()
                    .map(|t| Span::new(t.span.end, t.span.end))
                    .unwrap_or_default()
            })
    }

    fn skip_newlines(&mut self) {
        while self.check(&Token::Newline) {
            self.advance();
        }
    }

    fn recover_to_next_item(&mut self) {
        // Skip tokens until we find a likely module item boundary
        while !self.is_at_end() {
            match self.peek() {
                Some(Token::Import) | Some(Token::Fn) | Some(Token::Struct) | Some(Token::Enum)
                | Some(Token::Trait) | Some(Token::Impl) | Some(Token::Type) | Some(Token::Let)
                | Some(Token::Pub) | Some(Token::Dedent) | Some(Token::AtSpec)
                | Some(Token::AtExample) | Some(Token::Confidence) | Some(Token::GeneratedBy)
                | Some(Token::Prompt) | Some(Token::HumanEditCount) => break,
                _ => {
                    self.advance();
                }
            }
        }
    }

    /// Parse AI annotation attributes (e.g., @confidence(high), @generated_by("model"))
    fn parse_attributes(&mut self) -> ParseResult<Vec<Attribute>> {
        let mut attributes = Vec::new();

        while let Some(token) = self.peek() {
            match token {
                Token::Confidence | Token::GeneratedBy | Token::Prompt | Token::HumanEditCount => {
                    attributes.push(self.parse_attribute()?);
                }
                _ => break,
            }
        }

        Ok(attributes)
    }

    /// Parse a single attribute
    fn parse_attribute(&mut self) -> ParseResult<Attribute> {
        let start_span = self.current_span();

        // Get the attribute name from the token
        let name = match self.peek() {
            Some(Token::Confidence) => {
                self.advance();
                Ident::new("confidence", start_span)
            }
            Some(Token::GeneratedBy) => {
                self.advance();
                Ident::new("generated_by", start_span)
            }
            Some(Token::Prompt) => {
                self.advance();
                Ident::new("prompt", start_span)
            }
            Some(Token::HumanEditCount) => {
                self.advance();
                Ident::new("human_edit_count", start_span)
            }
            _ => {
                return Err(ParseError::unexpected_token(
                    "attribute",
                    self.peek().unwrap_or(&Token::Eof),
                    self.current_span(),
                ))
            }
        };

        // Parse arguments: (arg1, arg2, name=value)
        let arguments = if self.check(&Token::LParen) {
            self.parse_attribute_args()?
        } else {
            Vec::new()
        };

        let end_span = self.current_span();
        Ok(Attribute {
            name,
            arguments,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse attribute arguments: (arg1, arg2, name=value)
    fn parse_attribute_args(&mut self) -> ParseResult<Vec<AttributeArg>> {
        self.consume(Token::LParen, "`(`")?;
        let mut args = Vec::new();

        if !self.check(&Token::RParen) {
            loop {
                args.push(self.parse_attribute_arg()?);
                if !self.match_token(&Token::Comma) {
                    break;
                }
            }
        }

        self.consume(Token::RParen, "`)`")?;
        Ok(args)
    }

    /// Parse a single attribute argument (positional or named)
    fn parse_attribute_arg(&mut self) -> ParseResult<AttributeArg> {
        // Check if this is a named argument: name = value
        if let Some(Token::Ident(name)) = self.peek() {
            let name = name.clone();
            // Look ahead to see if followed by =
            let saved_pos = self.position;
            self.advance();
            if self.match_token(&Token::Assign) {
                let value = self.parse_attribute_value()?;
                let name_ident = Ident::new(name, self.current_span());
                return Ok(AttributeArg::Named {
                    name: name_ident,
                    value,
                });
            }
            // Not a named argument, backtrack
            self.position = saved_pos;
        }

        // Positional argument
        let value = self.parse_attribute_value()?;
        Ok(AttributeArg::Positional(value))
    }

    /// Parse an attribute value (string, number, bool, identifier)
    fn parse_attribute_value(&mut self) -> ParseResult<AttributeValue> {
        match self.peek() {
            Some(Token::String(s)) => {
                let s = s.clone();
                self.advance();
                Ok(AttributeValue::String(s))
            }
            Some(Token::Integer(n)) => {
                let n = n.clone();
                self.advance();
                // Parse as i64
                match n.parse::<i64>() {
                    Ok(val) => Ok(AttributeValue::Integer(val)),
                    Err(_) => Err(ParseError::new(
                        ParseErrorKind::InvalidSyntax,
                        self.current_span(),
                        format!("Invalid integer: {}", n),
                    )),
                }
            }
            Some(Token::Float(n)) => {
                let n = n.clone();
                self.advance();
                // Parse as f64
                match n.parse::<f64>() {
                    Ok(val) => Ok(AttributeValue::Float(val)),
                    Err(_) => Err(ParseError::new(
                        ParseErrorKind::InvalidSyntax,
                        self.current_span(),
                        format!("Invalid float: {}", n),
                    )),
                }
            }
            Some(Token::True) => {
                self.advance();
                Ok(AttributeValue::Bool(true))
            }
            Some(Token::False) => {
                self.advance();
                Ok(AttributeValue::Bool(false))
            }
            Some(Token::Ident(name)) => {
                let name = name.clone();
                let span = self.current_span();
                self.advance();
                Ok(AttributeValue::Ident(Ident::new(name, span)))
            }
            Some(token) => Err(ParseError::unexpected_token(
                "attribute value",
                token,
                self.current_span(),
            )),
            None => Err(ParseError::unexpected_eof(
                "attribute value",
                self.current_span(),
            )),
        }
    }

    /// Parse a @spec annotation
    /// Format: @spec "description" or @spec "description" @test_for(function_name)
    fn parse_spec(&mut self) -> ParseResult<Spec> {
        let start_span = self.current_span();
        self.consume(Token::AtSpec, "@spec")?;

        // Parse the description string
        let description = match self.peek() {
            Some(Token::String(s)) => {
                let desc = s.clone();
                self.advance();
                desc
            }
            Some(token) => {
                return Err(ParseError::unexpected_token(
                    "string literal for spec description",
                    token,
                    self.current_span(),
                ))
            }
            None => return Err(ParseError::unexpected_eof("spec description", self.current_span())),
        };

        // Check for optional @test_for annotation
        let test_for = if self.check(&Token::AtTestFor) {
            self.advance(); // consume @test_for
            self.consume(Token::LParen, "`(`")?;
            let func_name = match self.peek() {
                Some(Token::Ident(s)) => {
                    let name = s.clone();
                    self.advance();
                    name
                }
                Some(token) => {
                    return Err(ParseError::unexpected_token(
                        "function name",
                        token,
                        self.current_span(),
                    ))
                }
                None => return Err(ParseError::unexpected_eof("function name", self.current_span())),
            };
            self.consume(Token::RParen, "`)")?;
            Some(func_name)
        } else {
            None
        };

        let end_span = self.current_span();
        Ok(Spec {
            description,
            test_for,
            span: Span::new(start_span.start, end_span.end),
        })
    }

    /// Parse an @example annotation
    /// Format: @example ["caption"] { code } or @example ["caption"] @test_for(func) { code }
    fn parse_example(&mut self) -> ParseResult<Example> {
        let start_span = self.current_span();
        self.consume(Token::AtExample, "@example")?;

        // Parse optional caption string
        let caption = if let Some(Token::String(s)) = self.peek() {
            let cap = s.clone();
            self.advance();
            Some(cap)
        } else {
            None
        };

        // Check for optional @test_for annotation
        let test_for = if self.check(&Token::AtTestFor) {
            self.advance(); // consume @test_for
            self.consume(Token::LParen, "`(`")?;
            let func_name = match self.peek() {
                Some(Token::Ident(s)) => {
                    let name = s.clone();
                    self.advance();
                    name
                }
                Some(token) => {
                    return Err(ParseError::unexpected_token(
                        "function name",
                        token,
                        self.current_span(),
                    ))
                }
                None => return Err(ParseError::unexpected_eof("function name", self.current_span())),
            };
            self.consume(Token::RParen, "`)")?;
            Some(func_name)
        } else {
            None
        };

        // Parse the code expression (typically a block or function)
        self.skip_newlines();
        let code = Box::new(self.parse_expr()?);

        let end_span = self.current_span();
        Ok(Example {
            caption,
            code,
            test_for,
            span: Span::new(start_span.start, end_span.end),
        })
    }
}

/// Parse source code into an AST module
pub fn parse(tokens: Vec<SpannedToken>) -> ParseResult<Module> {
    let mut parser = Parser::new(tokens);
    parser.parse_module()
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_tokens(tokens: Vec<Token>) -> Vec<SpannedToken> {
        tokens
            .into_iter()
            .map(|t| SpannedToken {
                token: t,
                span: Span::default(),
            })
            .collect()
    }

    #[test]
    fn test_parse_literal() {
        let tokens = make_tokens(vec![Token::Integer("42".to_string()), Token::Eof]);
        let mut parser = Parser::new(tokens);
        let expr = parser.parse_expr().unwrap();

        assert!(matches!(expr, Expr::Literal(Literal::Integer(42))));
    }

    #[test]
    fn test_parse_binary_expr() {
        let tokens = make_tokens(vec![
            Token::Integer("1".to_string()),
            Token::Plus,
            Token::Integer("2".to_string()),
            Token::Eof,
        ]);
        let mut parser = Parser::new(tokens);
        let expr = parser.parse_expr().unwrap();

        assert!(matches!(
            expr,
            Expr::Binary {
                op: BinaryOp::Add,
                ..
            }
        ));
    }

    #[test]
    fn test_parse_let_stmt() {
        let tokens = make_tokens(vec![
            Token::Let,
            Token::Ident("x".to_string()),
            Token::Assign,
            Token::Integer("5".to_string()),
            Token::Eof,
        ]);
        let mut parser = Parser::new(tokens);
        let stmt = parser.parse_stmt().unwrap();

        assert!(matches!(stmt, Stmt::Let { .. }));
    }
}
