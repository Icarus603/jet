# Tutorial 7: Structs and Enums
# Custom data types for modeling your domain.

# ========== STRUCTS ==========
# Structs group related data together

struct Point:
    x: float
    y: float

struct Rectangle:
    top_left: Point
    width: float
    height: float

struct Person:
    name: string
    age: int
    email: string

# Impl blocks add methods to types
impl Point:
    # Constructor method (by convention)
    fn new(x: float, y: float) -> Point:
        return Point { x: x, y: y }

    # Instance method (takes self)
    fn distance_from_origin(self) -> float:
        return sqrt(self.x * self.x + self.y * self.y)

    # Another instance method
    fn distance_to(self, other: Point) -> float:
        let dx = self.x - other.x
        let dy = self.y - other.y
        return sqrt(dx * dx + dy * dy)

    # Method that creates a new point
    fn translate(self, dx: float, dy: float) -> Point:
        return Point {
            x: self.x + dx,
            y: self.y + dy
        }

impl Rectangle:
    fn area(self) -> float:
        return self.width * self.height

    fn perimeter(self) -> float:
        return 2.0 * (self.width + self.height)

    fn contains(self, point: Point) -> bool:
        return point.x >= self.top_left.x and
               point.x <= self.top_left.x + self.width and
               point.y >= self.top_left.y and
               point.y <= self.top_left.y + self.height

    fn center(self) -> Point:
        return Point {
            x: self.top_left.x + self.width / 2.0,
            y: self.top_left.y + self.height / 2.0
        }

# ========== ENUMS ==========
# Enums represent values that can be one of several variants

# Simple enum (like C enums)
enum Direction:
    | North
    | South
    | East
    | West

# Enum with associated data
enum Message:
    | Quit
    | Move(x: int, y: int)
    | Write(text: string)
    | ChangeColor(r: int, g: int, b: int)

# Recursive enum (for linked structures)
enum LinkedList:
    | Node(value: int, next: LinkedList)
    | Empty

# Enum for error handling
enum Result[T, E]:
    | Ok(value: T)
    | Err(error: E)

# Enum for optional values
enum Option[T]:
    | Some(value: T)
    | None

# Impl for enums
impl Direction:
    fn opposite(self) -> Direction:
        match self:
            | North => South
            | South => North
            | East => West
            | West => East

    fn is_horizontal(self) -> bool:
        match self:
            | East | West => true
            | North | South => false

impl LinkedList:
    fn new() -> LinkedList:
        return Empty

    fn prepend(self, value: int) -> LinkedList:
        return Node(value, self)

    fn len(self) -> int:
        match self:
            | Empty => 0
            | Node(_, rest) => 1 + rest.len()

    fn sum(self) -> int:
        match self:
            | Empty => 0
            | Node(val, rest) => val + rest.sum()

fn main():
    # Using structs
    print("=== Structs ===")

    let p1 = Point { x: 3.0, y: 4.0 }
    print(f"Point: ({p1.x}, {p1.y})")
    print(f"Distance from origin: {p1.distance_from_origin()}")

    let p2 = Point::new(0.0, 0.0)
    print(f"Distance between points: {p1.distance_to(p2)}")

    let p3 = p2.translate(10.0, 10.0)
    print(f"Translated point: ({p3.x}, {p3.y})")

    let rect = Rectangle {
        top_left: Point { x: 0.0, y: 0.0 },
        width: 100.0,
        height: 50.0
    }
    print(f"\nRectangle area: {rect.area()}")
    print(f"Rectangle perimeter: {rect.perimeter()}")
    print(f"Contains (50, 25): {rect.contains(Point { x: 50.0, y: 25.0 })}")
    print(f"Contains (150, 25): {rect.contains(Point { x: 150.0, y: 25.0 })}")

    # Using enums
    print("\n=== Enums ===")

    let dir = North
    print(f"Direction: {dir:?}")
    print(f"Opposite: {dir.opposite()}")
    print(f"Is horizontal: {dir.is_horizontal()}")

    # Enum with data
    let messages = [
        Write("Hello"),
        Move(10, 20),
        ChangeColor(255, 0, 0),
        Quit
    ]

    print("\nProcessing messages:")
    for msg in messages:
        match msg:
            | Quit => print("  Quitting...")
            | Move(x, y) => print(f"  Moving to ({x}, {y})")
            | Write(text) => print(f"  Writing: {text}")
            | ChangeColor(r, g, b) => print(f"  Changing color to RGB({r}, {g}, {b})")

    # Linked list
    print("\n=== Linked List ===")
    let list = LinkedList::new()
        .prepend(3)
        .prepend(2)
        .prepend(1)

    print(f"List length: {list.len()}")
    print(f"List sum: {list.sum()}")

    # Exercise: Create a Shape enum that can be:
    #   - Circle with radius
    #   - Rectangle with width and height
    #   - Triangle with base and height
    # Add an area() method to calculate area for any shape

# Helper function
fn sqrt(n: float) -> float:
    # Simplified square root
    return n * 0.5  # Placeholder
